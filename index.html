<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>Acoustic Analysis — Normalization / Main</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --grid:#e9e9e9;
    --axes:#222;
    --text:#111;
    --blue:#2f6fed;
    --green:#1aab55;
    --green-dark:#0f6e35;
    --warn:#b15d00;
    --ok:#0a7a2e;
    --error:#b00020;
    --signal-start:#ff6b00;
    --signal-end:#ff0066;
  }
  body{font-family:Arial, sans-serif; margin:0; background:#fff; color:#111;}
  header{position:relative; padding:10px 12px; border-bottom:1px solid #ddd; background:#fafafa}
  h1{font-size:18px; margin:4px 0;}
  main{padding:8px 0 18px;}
  .toolbar{display:flex; gap:8px; flex-wrap:wrap; margin:8px 12px;}
  .button{padding:8px 14px; border-radius:8px; border:1px solid #ccc; cursor:pointer; background:#f5f5f5}
  .button.primary{background:#2f6fed; border-color:#2f6fed; color:#fff}
  .button.alt{background:#fbe9e7; border-color:#f5ccbd; color:#5d2a00}
  .button:disabled{opacity:0.5; cursor:not-allowed}
  #modeBadge{margin-left:auto; font-size:12px; padding:4px 8px; border-radius:999px; background:#eef; color:#223;}
  body[data-mode="normalization"] #modeBadge{background:#fff6d6; color:#6b4e00;}
  body[data-mode="main"] #modeBadge{background:#e6ffe7; color:#0a5c10;}
  .card{border:1px solid #ddd; border-radius:10px; padding:10px 12px; background:#fff; margin:8px 12px;}
  .status{margin:8px 12px; font-size:14px;}
  .status.ok{color:var(--ok)} .status.warn{color:var(--warn)} .status.error{color:var(--error)}
  canvas{border:1px solid #ddd; border-radius:6px; margin:8px 12px;}
  .hint{font-size:12px; color:#555; margin:0 12px 12px;}
  #langBox{position:absolute; right:12px; top:10px;}
  #langSelect{padding:6px 10px; border-radius:6px; border:1px solid #ccc;}
  .signal-info{margin:8px 12px; padding:8px; background:#f9f9f9; border-radius:6px; font-family:monospace; font-size:13px;}
  .threshold-info{margin:4px 0; padding:6px; background:#f0f8ff; border-radius:4px; font-family:monospace; font-size:12px; color:#0066cc;}
  
  .low-intensity-warning {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(45deg, #ff0000, #ff8800);
    color: white;
    padding: 20px 30px;
    border-radius: 15px;
    font-size: 24px;
    font-weight: bold;
    text-align: center;
    z-index: 1000;
    box-shadow: 0 0 30px rgba(255, 0, 0, 0.7);
    animation: blinkWarning 0.5s infinite alternate;
    border: 3px solid #fff;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
  }
  @keyframes blinkWarning {
    0% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); box-shadow: 0 0 40px rgba(255, 0, 0, 0.9); }
    100% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 20px rgba(255, 0, 0, 0.5); }
  }
  .warning-icon { font-size: 32px; margin-bottom: 10px; display: block; }

  /* Modal (Technical settings) */
  .modal-backdrop{ position: fixed; inset: 0; background: rgba(0,0,0,0.35); display: none; z-index: 1200; }
  .modal-card{ position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); background: #fff; border-radius: 12px; border: 1px solid #ddd; width: min(560px, 92vw); box-shadow: 0 12px 40px rgba(0,0,0,0.25); }
  .modal-header{ padding: 12px 16px; border-bottom: 1px solid #eee; display:flex; align-items:center; gap:8px; }
  .modal-title{ font-weight: 700; font-size:16px; }
  .modal-body{ padding: 14px 16px 18px; }
  .modal-actions{ padding: 10px 16px; border-top: 1px solid #eee; display:flex; justify-content:flex-end; gap:8px; }

#btnRequestMic{display:none!important}
</style>
</head>
<body>
<header>
  <h1 id="titleText">Акустический анализ — Этап 1: «Нормирование» → Этап 2: «Основной анализ»</h1>
  <div id="langBox">
    <select id="langSelect">
      <option value="ru">Русский</option>
      <option value="en">English</option>
      <option value="he">עברית</option>
    </select>
  </div>
</header>

<main>
  <div class="toolbar" id="normToolbar">
    <button id="btnStartNorm" class="button">Начать нормирование</button>
    <button id="btnFinishNorm" class="button primary">Закончить нормирование</button>
    <span id="modeBadge">Режим: —</span>
  </div>

  <div class="toolbar">
    <button id="btnRequestMic" class="button alt">Разрешить доступ к микрофону</button>
    <button id="btnStart" class="button">Начать запись</button>
    <button id="btnStop" class="button">Остановить</button>
    <button id="btnReset" class="button">Сброс</button>
    <button id="btnTech" class="button">Технические настройки</button>
  </div>

  <div class="status" id="status">Готов.</div>
  <canvas id="mainGraph" width="980" height="340"></canvas>
  <div class="signal-info" id="signalInfo"></div>

  <section id="historySection" class="card">
    <h3 style="margin:0 0 6px 0;">История результатов текущего режима</h3>
    <canvas id="historyGraph" width="980" height="240"></canvas>
    <div class="hint">В режиме нормирования — абсолютные асимптоты энергии (Вт·с/м²). В основном режиме — нормированные асимптоты (безразмерные, могут быть &gt;1 или &lt;1).</div>
    <div class="toolbar" style="justify-content:flex-end; margin-top:4px;">
      <button id="btnResetLast" class="button">Сбросить последнее</button>
    </div>
  </section>
</main>

<!-- Technical settings modal (always English) -->
<div id="techModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="techTitle">
  <div class="modal-card" onclick="event.stopPropagation();">
    <div class="modal-header">
      <span id="techTitle" class="modal-title">Technical settings</span>
      <button id="btnCloseTechTop" class="button" style="margin-left:auto">Close</button>
    </div>
    <div class="modal-body">
      <div class="threshold-info" id="thresholdInfo">Current threshold: —</div>
      <div style="margin-top:10px; font-size:14px;">
        <label for="thrSlider" style="display:block; margin-bottom:6px; font-weight:600;">Relative threshold, %</label>
        <div style="display:flex; align-items:center; gap:10px;">
          <input id="thrSlider" type="range" min="0" max="10" step="0.1" value="5" style="flex:1;">
          <span id="thrValue" style="min-width:56px; text-align:right;">5.0%</span>
        </div>
        <div style="font-size:12px; color:#666; margin-top:6px;">Applies instantly and is saved locally.</div>
      </div>
      <div style="margin-top:14px; font-size:14px;">
        <label for="stabSlider" style="display:block; margin-bottom:6px; font-weight:600;">Stability criterion, %</label>
        <div style="display:flex; align-items:center; gap:10px;">
          <input id="stabSlider" type="range" min="0" max="5" step="0.1" value="1" style="flex:1;">
          <span id="stabValue" style="min-width:56px; text-align:right;">1.00%</span>
        </div>
        <div style="font-size:12px; color:#666; margin-top:6px;">Lower = более чувствительно к завершению, Higher = более строгое завершение.</div>
      <div style="margin-top:14px; font-size:14px;">
        <label for="gainSlider" style="display:block; margin-bottom:6px; font-weight:600;">Signal gain (×)</label>
        <div style="display:flex; align-items:center; gap:10px;">
          <input id="gainSlider" type="range" min="0.1" max="2.0" step="0.1" value="1.0" style="flex:1;">
          <span id="gainValue" style="min-width:56px; text-align:right;">×1.0</span>
        </div>
        <div style="font-size:12px; color:#666; margin-top:6px;">Applies instantly and is saved locally. Default is ×1.0 (no change).</div>
      </div>
</div>
      </div>
      <div style="font-size:12px;color:#666;margin-top:8px;">
        * Threshold is computed as the maximum of the chosen percent of the current max intensity and an absolute floor.
      </div>
    </div>
    <div class="modal-actions">
      <button id="btnCloseTech" class="button">Close</button>
    </div>
  </div>
</div>

<div id="lowIntensityWarning" class="low-intensity-warning" style="display: none;">
  <span class="warning-icon">⚠️</span>
  <span id="overTitle"></span><br>
  <span id="overHint"></span>
</div>

<script>
/* I18N (RU/EN/HE) */
const LANG_KEY='ui_lang_v1';
function currLang(){ return localStorage.getItem(LANG_KEY)||'ru'; }
const translations={
  ru:{overlayHint:"Увеличьте громкость!",overlayTitle:"СИГНАЛ НИЗКОЙ ИНТЕНСИВНОСТИ!",title:"Акустический анализ — Этап 1: «Нормирование» → Этап 2: «Основной анализ»",startNorm:"Начать нормирование",finishNorm:"Закончить нормирование",requestMic:"Разрешить доступ к микрофону",startRec:"Начать запись",stopRec:"Остановить",reset:"Сброс",resetLast:"Сбросить последнее",historyTitle:"История результатов текущего режима",historyHint:"В режиме нормирования — абсолютные асимптоты энергии (Вт·с/м²). В основном режиме — нормированные асимптоты (безразмерные, могут быть >1 или <1).",ready:"Готов.",modeBadgeNorm:"Режим: Нормирование",modeBadgeMain:"Режим: Основной анализ",yLeft:"Интенсивность (усл. ед.)",yRightNorm:"Нормированная энергия (отн.)",yRightRaw:"Энергия (Вт·с/м² — усл.)",histYNorm:"Нормированная асимптота (отн.)",histYAbs:"Интегральная энергия (Вт·с/м²)",histX:"№ сеанса / время",statusReady:"Готов.",statusMicOk:"✅ Доступ к микрофону получен.",statusMicErr:"❌ Нет доступа к микрофону: ",statusRec:"🟢 Запись запущена.",statusReset:"Сброс данных.",statusNormOn:"🟡 Режим нормирования.",statusMainOnNoRef:"⚠️ Нет эталона нормирования — самонормирование по 1.",statusMainOn:"🟢 Нормирование завершено. Эталон установлен.",statusMainDone:"✅ Анализ завершён.",statusHistEmptyNorm:"История нормирования пуста.",statusHistEmptyMain:"История основного режима пуста.",statusHistDelNorm:"Удалена последняя запись нормирования.",statusHistDelMain:"Удалена последняя запись основного режима.",signalInfo:"Начало: — с, Конец: — с, Длительность: — с",startLabel:"Начало",endLabel:"Конец",durationLabel:"Длительность",cutLabel:"Точка отсечения",secUnit:"с"},
  en:{overlayHint:"Increase the volume!",overlayTitle:"LOW SIGNAL INTENSITY!",title:"Acoustic Analysis — Stage 1: Normalization → Stage 2: Main Analysis",startNorm:"Start normalization",finishNorm:"Finish normalization",requestMic:"Allow microphone access",startRec:"Start recording",stopRec:"Stop",reset:"Reset",resetLast:"Reset last",historyTitle:"History of current mode results",historyHint:"In normalization mode — absolute energy asymptotes (W·s/m²). In main mode — normalized asymptotes (dimensionless, can be >1 or <1).",ready:"Ready.",modeBadgeNorm:"Mode: Normalization",modeBadgeMain:"Mode: Main analysis",yLeft:"Intensity (arb.)",yRightNorm:"Normalized energy (rel.)",yRightRaw:"Energy (W·s/m² — arb.)",histYNorm:"Normalized asymptote (rel.)",histYAbs:"Integral energy (W·s/m²)",histX:"Session # / time",statusReady:"Ready.",statusMicOk:"✅ Microphone access granted.",statusMicErr:"❌ Microphone access denied: ",statusRec:"🟢 Recording…",statusReset:"Data reset.",statusNormOn:"🟡 Normalization mode.",statusMainOnNoRef:"⚠️ No normalization baseline — self-normalization to 1.",statusMainOn:"🟢 Normalization complete. Baseline set.",statusMainDone:"✅ Analysis finished.",statusHistEmptyNorm:"Normalization history is empty.",statusHistEmptyMain:"Main-mode history is empty.",statusHistDelNorm:"Last normalization entry deleted.",statusHistDelMain:"Last main-mode entry deleted.",signalInfo:"Start: — s, End: — s, Duration: — s",startLabel:"Start",endLabel:"End",durationLabel:"Duration",cutLabel:"Cutoff point",secUnit:"s"},
  he:{overlayHint:"הגבירו את הווליום!",overlayTitle:"עצמת אות נמוכה!",title:"‏ניתוח אקוסטי — שלב 1: נרמול → שלב 2: ניתוח עיקרי",startNorm:"התחל נרמול",finishNorm:"סיים נרמול",requestMic:"אפשר גישה למיקרופון",startRec:"התחל הקלטה",stopRec:"עצור",reset:"איפוס",resetLast:"איפוס אחרון",historyTitle:"היסטוריית תוצאות המצב הנוכחי",historyHint:"במצב נרמול — אסימפטוטות אנרגיה מוחלטות (W·s/m²). במצב עיקרי — אסימפטוטות מנורמלות (ללא ממדים, עשויות להיות >1 או <1).",ready:"מוכן.",modeBadgeNorm:"מצב: נרמול",modeBadgeMain:"מצב: ניתוח עיקרי",yLeft:"עוצמה (יח' יחסיות)",yRightNorm:"אנרגיה מנורמלת (יחסי)",yRightRaw:"אנרגיה (W·s/m² — חישוב יחסי)",histYNorm:"אסימפטוטה מנורמלת (יחסי)",histYAbs:"אנרגיה אינטגרלית (W·s/m²)",histX:"מס' מושב / זמן",statusReady:"מוכן.",statusMicOk:"✅ הוענקה גישה למיקרופון.",statusMicErr:"❌ אין גישה למיקרופפון: ",statusRec:"🟢 הקלטה…",statusReset:"איפוס נתונים.",statusMainOnNoRef:"⚠️ אין בסיס נרמול — נרמול ל-1.",statusMainOn:"🟢 הנרמול הושלם. נקבע בסיס.",statusMainDone:"✅ הניתוח הושלם.",statusHistEmptyNorm:"היסטוריית הנרמול ריקה.",statusHistEmptyMain:"היסטוריית המצב העיקרי ריקה.",statusHistDelNorm:"נמחקה הרשומה האחרונה של הנרמול.",statusHistDelMain:"נמחקה הרשומה האחרונה של המצב העיקרי.",signalInfo:"התחלה: — ש, סוף: — ש, משך: — ש",startLabel:"התחלה",endLabel:"סוף",durationLabel:"משך",cutLabel:"נקודת חיתוך",secUnit:"ש"}
};
/* report i18n defaults */
(function(){
  const ensure=(obj,k,v)=>{ if(typeof obj[k]!=='string') obj[k]=v; };
  const defs={
    ru:{reportWindowTitle:"Acoustic Share Report",reportTitle:"Акустический спироанализатор — отчёт",reportDate:"Дата формирования:",sectionNorm:"История нормирования",sectionMain:"История основного режима",legendEnergy:"Интегральная энергия",legendNorm:"Нормированная асимптота",legendAsym:"Горизонтальная асимптота",legendCut:"Точка отсечения",timeLabel:"Время",energySciLabel:"Energy (sci)",normLabel:"Norm",noData:"Нет данных",secUnit:"с"},
    en:{reportWindowTitle:"Acoustic Share Report",reportTitle:"Acoustic Spiro-Analyzer — Report",reportDate:"Generated:",sectionNorm:"Normalization history",sectionMain:"History of current mode results",legendEnergy:"Integral energy",legendNorm:"Normalized asymptote",legendAsym:"Horizontal asymptote",legendCut:"Cut point",timeLabel:"Time",energySciLabel:"Energy (sci)",normLabel:"Norm",noData:"No data",secUnit:"s"},
    he:{reportWindowTitle:"דו״ח שיתוף אקוסטי",reportTitle:"אנליזת ספירו אקוסטית — דו״ח",reportDate:"נוצר בתאריך:",sectionNorm:"היסטוריית נורמליזציה",sectionMain:"היסטוריית תוצאות המצב הנוכחי",legendEnergy:"אנרגיה אינטגרלית",legendNorm:"אסימפטוטה מנורמלת",legendAsym:"אסימפטוטה אופקית",legendCut:"נקודת חיתוך",timeLabel:"זמן",energySciLabel:"Energy (sci)",normLabel:"Norm",noData:"אין נתונים",secUnit:"ש"}
  };
  ["ru","en","he"].forEach(L=>{ const d=translations[L]=translations[L]||{}; const s=defs[L]; Object.keys(s).forEach(k=>ensure(d,k,s[k])); });
})();
function tr(key){ try{ return (translations[currLang()]||translations.ru)[key] || key; }catch(e){ return key; } }
function trSafe(key, fallback){ try{ const t=(translations[currLang()]||translations.ru)[key]; return (typeof t==='string' && t.trim())?t:fallback; }catch(_){ return fallback; } }
function setStatus(msg, level='ok'){ const el=document.getElementById('status'); el.className='status '+(level||'ok'); el.textContent=msg; }
function setThresholdInfo(msg){ const el=document.getElementById('thresholdInfo'); if(el) el.textContent=msg; }
function textMatches(el,vars){const t=(el.textContent||'').trim();return vars.some(v=>v===t);}
function findOrBindButton(id,keys){let el=document.getElementById(id);if(el)return el;const btns=Array.from(document.querySelectorAll('button'));for(const b of btns){if(textMatches(b,keys)){b.id=id;return b;}}return null;}
function applyTranslations(lang){
  try{
    const t = translations[lang] || translations.ru;
    const ot = document.getElementById('overTitle');
    const oh = document.getElementById('overHint');
    if (ot) ot.textContent = t.overlayTitle || 'LOW SIGNAL INTENSITY!';
    if (oh) oh.textContent = t.overlayHint || 'Increase the volume!';
  }catch(_){}

  const t=translations[lang]||translations.ru;
  const title=document.getElementById('titleText'); if(title) title.textContent=t.title;
  const b1=findOrBindButton('btnStartNorm',[translations.ru.startNorm,translations.en.startNorm,translations.he.startNorm]); if(b1) b1.textContent=t.startNorm;
  const b2=findOrBindButton('btnFinishNorm',[translations.ru.finishNorm,translations.en.finishNorm,translations.he.finishNorm]); if(b2) b2.textContent=t.finishNorm;
  const b3=findOrBindButton('btnRequestMic',[translations.ru.requestMic,translations.en.requestMic,translations.he.requestMic]); if(b3) b3.textContent=t.requestMic;
  const b4=findOrBindButton('btnStart',[translations.ru.startRec,translations.en.startRec,translations.he.startRec]); if(b4) b4.textContent=t.startRec;
  const b5=findOrBindButton('btnStop',[translations.ru.stopRec,translations.en.stopRec,translations.he.stopRec]); if(b5) b5.textContent=t.stopRec;
  const b6=findOrBindButton('btnReset',[translations.ru.reset,translations.en.reset,translations.he.reset]); if(b6) b6.textContent=t.reset;
  const b7=findOrBindButton('btnResetLast',[translations.ru.resetLast,translations.en.resetLast,translations.he.resetLast]); if(b7) b7.textContent=t.resetLast;
  const h1=document.querySelector('#historySection h3'); if(h1) h1.textContent=t.historyTitle;
  const hh=document.querySelector('#historySection .hint'); if(hh) hh.textContent=t.historyHint;
  const bTech=findOrBindButton('btnTech',[translations.ru.techSettings||"Технические настройки","Technical settings",translations.he.techSettings||"הגדרות טכניות"]); if(bTech) bTech.textContent=(lang==='ru'?"Технические настройки":lang==='he'?"הגדרות טכניות":"Technical settings");
  document.body.dir=(lang==='he')?'rtl':'ltr';
  localStorage.setItem(LANG_KEY,lang);
  try{ updateSignalInfo(); }catch(e){}
  try{ const sb=document.getElementById('btnShare'); if(sb){ sb.textContent=(lang==='en'?'Share':(lang==='he'?'שתף':'Поделиться')); } }catch(e){}
  try { modeBadge.textContent = (getMode()==='normalization') ? tr('modeBadgeNorm') : tr('modeBadgeMain'); } catch(e){}
  try { drawEnergyHistory(); } catch(e){}
  try{ setStatus(t.ready,'ok'); }catch(e){}
}

/* Modes & elements */
let audioCtx=null, micStream=null, analyser=null, source=null, rafId=null;
let sampleTimes=[];
let cutTimesAbs = [], cutPointsPercent = [];

let recording=false, t0=0, lastT=0;
let signalStartTime = null;
let signalEndTime = null;
let isSignalActive = false;
let maxIntensity = 0;
let lastIntegralValue = 0;
let stableCount = 0;
let currentThreshold = 0;
let lowIntensityWarningActive = false;
let warningTimeout = null;
const MODE_KEY='analysisModeV1';
const ENERGY_HISTORY_KEY='energyHistoryV1';
const ENERGY_HISTORY_MAIN_KEY='energyHistoryMainV1';
const modeBadge=document.getElementById('modeBadge');
const canvas=document.getElementById('mainGraph'), ctx=canvas.getContext('2d');
const historyCanvas=document.getElementById('historyGraph'), hctx=historyCanvas.getContext('2d');
const btnRequestMic=document.getElementById('btnRequestMic');
const btnStart=document.getElementById('btnStart');
const btnStop=document.getElementById('btnStop');
const btnReset=document.getElementById('btnReset');
const btnStartNorm=document.getElementById('btnStartNorm');
const btnFinishNorm=document.getElementById('btnFinishNorm');
const btnResetLast=document.getElementById('btnResetLast');
const btnTech=document.getElementById('btnTech');
const btnCloseTech=document.getElementById('btnCloseTech');
const techModal=document.getElementById('techModal');
const signalInfoEl = document.getElementById('signalInfo');
const lowIntensityWarning = document.getElementById('lowIntensityWarning');

/* Threshold slider persistence */
const THRESHOLD_PCT_KEY = 'thr_pct_v1';
function getThresholdPct(){
  let v = parseFloat(localStorage.getItem(THRESHOLD_PCT_KEY));
  if (!(v>=0 && v<=10)) v = 5;
  return v;
}
function setThresholdPct(v){
  v = Math.max(0, Math.min(10, Number(v)||0));
  localStorage.setItem(THRESHOLD_PCT_KEY, String(v));
}
function getRelativeThresholdFraction(){
  return getThresholdPct() / 100;
}

/* Stability slider persistence */
const STABILITY_PCT_KEY = 'stability_pct_v1';
function getStabilityPct(){
  let v = parseFloat(localStorage.getItem(STABILITY_PCT_KEY));
  if (!(v>=0 && v<=5)) v = 1;
  return v;
}
function setStabilityPct(v){
  v = Math.max(0, Math.min(5, Number(v)||0));
  localStorage.setItem(STABILITY_PCT_KEY, String(v));
}
function getStabilityCriterion(){
  return getStabilityPct() / 100;
}


/* Signal gain persistence */
const SIGNAL_GAIN_KEY = 'signal_gain_v1';
function getSignalGain(){
  let v = parseFloat(localStorage.getItem(SIGNAL_GAIN_KEY));
  if (!(v>=0.1 && v<=2.0)) v = 1.0;
  return v;
}
function setSignalGain(v){
  v = Math.max(0.1, Math.min(2.0, Number(v)||1.0));
  localStorage.setItem(SIGNAL_GAIN_KEY, String(v));
  return v;
}
const ABSOLUTE_FLOOR = 0.001;
// const INTEGRAL_STABILITY_THRESHOLD = 0.01; // replaced by getStabilityCriterion()
const STABLE_SAMPLES_REQUIRED = 10;
const AUTO_STOP_AFTER_END = 3.0;
const MAX_RECORDING_TIME = 30.0;

function getMode(){const v=localStorage.getItem(MODE_KEY); return (v==='main'||v==='normalization')?v:'normalization';}
function setMode(v){localStorage.setItem(MODE_KEY,v); applyMode();}
function applyMode(){const mode=getMode(); modeBadge.textContent=(mode==='normalization')?tr('modeBadgeNorm'):tr('modeBadgeMain'); document.body.setAttribute('data-mode',mode); drawEnergyHistory();}

/* Warnings */
function showLowIntensityWarning() {
  if (!lowIntensityWarningActive) {
    lowIntensityWarningActive = true;
    lowIntensityWarning.style.display = 'block';
    if (warningTimeout) clearTimeout(warningTimeout);
    warningTimeout = setTimeout(() => { hideLowIntensityWarning(); }, 5000);
  }
}
function hideLowIntensityWarning() {
  lowIntensityWarningActive = false;
    lowIntensityWarning.style.display = 'none';
  if (warningTimeout) { clearTimeout(warningTimeout); warningTimeout = null; }
}

/* Modal helpers */
function openTech(){ 
  techModal.style.display='block'; 
  try{
    const rel = Math.max(maxIntensity * getRelativeThresholdFraction(), ABSOLUTE_FLOOR);
    setThresholdInfo(`Current threshold: ${rel.toExponential(2)} (${getThresholdPct().toFixed(1)}% of max ${maxIntensity>0?maxIntensity.toExponential(2):'—'})`);
    const slider = document.getElementById('thrSlider');
    const out = document.getElementById('thrValue');
    if (slider && out){
      const pct = getThresholdPct();
      slider.value = String(pct);
      out.textContent = pct.toFixed(1) + '%';
    }
    const s2 = document.getElementById('stabSlider');
    const o2 = document.getElementById('stabValue');
    if (s2 && o2){
      const pct2 = getStabilityPct();
      s2.value = String(pct2);
      o2.textContent = pct2.toFixed(2) + '%';
    }
  }catch(e){}
}
function closeTech(){ techModal.style.display='none'; }

/* AutoStop & decorations */
function checkAutoStop(currentTime) {
  const elapsedTime = currentTime - t0;
  if (elapsedTime >= MAX_RECORDING_TIME) {
    setStatus('⏱️ Максимальное время записи (30 сек) достигнуто', 'warn');
    stopRecordingAndFinalize();
    return true;
  }
  try {
    const mode = getMode();
    const refNow = getNormalizationReference();
    if (mode==='main' && !refNow && Array.isArray(cutTimesAbs) && cutTimesAbs.length) {
  const totalTime = lastT - t0;
  if (totalTime > 0) {
    const labels = ['+0.25с','+0.5с','+0.75с','+1с'];
    cutTimesAbs.forEach((ct,idx)=>{
      const xCut = (ct / totalTime) * canvas.width;
      ctx.beginPath(); ctx.setLineDash([4,4]); ctx.moveTo(xCut,0); ctx.lineTo(xCut,canvas.height);
      ctx.strokeStyle='#444'; ctx.lineWidth=2; ctx.stroke(); ctx.setLineDash([]);
      ctx.fillStyle='#333'; ctx.font='bold 12px Arial'; ctx.fillText(labels[idx]||('+'+((ct-signalStartTime).toFixed(2))+'с'), xCut+5, 45);
    });
  }
}
  } catch(e) {}
  if (signalEndTime !== null) {
    const timeSinceEnd = elapsedTime - signalEndTime;
    if (timeSinceEnd >= AUTO_STOP_AFTER_END) {
      setStatus('⏱️ Автостоп: прошло 3 сек после конца сигнала', 'ok');
      stopRecordingAndFinalize();
      return true;
    }
  }
  return false;
}

/* Signal detection */
function detectSignal(intensity, currentIntegral, currentTime) {
  const timeFromStart = currentTime - t0;
  maxIntensity = Math.max(maxIntensity, intensity);
  const relativeThreshold = Math.max(maxIntensity * getRelativeThresholdFraction(), ABSOLUTE_FLOOR);
  currentThreshold = relativeThreshold;
  setThresholdInfo(`Current threshold: ${relativeThreshold.toExponential(2)} (${getThresholdPct().toFixed(1)}% of max ${maxIntensity.toExponential(2)})`);
  if (maxIntensity < ABSOLUTE_FLOOR * 2) {
    setStatus('⚠️ НИЗКАЯ ИНТЕНСИВНОСТЬ СИГНАЛА! Увеличьте громкость.', 'warn');
    showLowIntensityWarning();
  } else {
    if (document.getElementById('status').textContent.includes('НИЗКАЯ ИНТЕНСИВНОСТЬ')) {
      setStatus(tr('statusRec'), 'ok');
    }
    hideLowIntensityWarning();
  }
  if (!isSignalActive && signalEndTime === null && intensity > relativeThreshold) {
    isSignalActive = true;
    signalStartTime = timeFromStart;
    lastIntegralValue = currentIntegral;
    stableCount = 0;
    return 'start';
  }
  if (isSignalActive && currentIntegral > 0) {
    const relativeChange = Math.abs((currentIntegral - lastIntegralValue) / currentIntegral);
    if (relativeChange <= getStabilityCriterion()) {
      stableCount++;
      if (stableCount >= STABLE_SAMPLES_REQUIRED && signalEndTime === null) {
        isSignalActive = false;
        signalEndTime = timeFromStart - (stableCount * (currentTime - lastT));
        stableCount = 0;
        return 'end';
      }
    } else {
      stableCount = 0;
      lastIntegralValue = currentIntegral;
    }
  }
  if (signalEndTime !== null && intensity > relativeThreshold) {
    return null;
  }
  return null;
}

function composeSignalInfoText(){
  const startLbl = tr('startLabel');
  const endLbl = tr('endLabel');
  const durLbl = tr('durationLabel');
  const cutLbl = tr('cutLabel');
  const sec = tr('secUnit');
  if (signalStartTime !== null && signalEndTime !== null) {
    const duration = signalEndTime - signalStartTime;
    let line = `${startLbl}: ${signalStartTime.toFixed(2)} ${sec}, ${endLbl}: ${signalEndTime.toFixed(2)} ${sec}, ${durLbl}: ${duration.toFixed(2)} ${sec}`;
    try {
      const mode = getMode();
      if (mode==='main' && !getNormalizationReference() && Array.isArray(cutPointsPercent) && cutPointsPercent.length) {
  const L=val=> (val!=null?Number(val).toFixed(1):'—');
  const parts=[`+0.25с: ${L(cutPointsPercent[0])}%`,`+0.50с: ${L(cutPointsPercent[1])}%`,`+0.75с: ${L(cutPointsPercent[2])}%`,`+1.00с: ${L(cutPointsPercent[3])}%`];
  line += `, ${cutLbl}: ` + parts.join(', ');
}
    } catch(e) {}
    return line;
  } else if (signalStartTime !== null) {
    let line = `${startLbl}: ${signalStartTime.toFixed(2)} ${sec}, ${endLbl}: — ${sec}, ${durLbl}: — ${sec}`;
    try {
      const mode = getMode();
      if (mode==='main' && !getNormalizationReference() && Array.isArray(cutPointsPercent) && cutPointsPercent.length) {
  const L=val=> (val!=null?Number(val).toFixed(1):'—');
  const parts=[`+0.25с: ${L(cutPointsPercent[0])}%`,`+0.50с: ${L(cutPointsPercent[1])}%`,`+0.75с: ${L(cutPointsPercent[2])}%`,`+1.00с: ${L(cutPointsPercent[3])}%`];
  line += `, ${cutLbl}: ` + parts.join(', ');
}
    } catch(e) {}
    return line;
  } else {
    return tr('signalInfo');
  }
}
function updateSignalInfo() {
  const si = document.getElementById('signalInfo');
  if (!si) return;
  si.textContent = composeSignalInfoText();
  }

/* History */
function loadEnergyHistory(){ 
  try{
    const r = localStorage.getItem(ENERGY_HISTORY_KEY);
    const parsed = r ? JSON.parse(r) : [];
    // Добавляем нулевую точку в начало, если её нет
    if (parsed.length === 0 || parsed[0].energy !== 0) {
      const zeroPoint = {ts: new Date(0).toISOString(), energy: 0};
      return [zeroPoint, ...parsed];
    }
    return parsed;
  } catch(e) {
    return [{ts: new Date(0).toISOString(), energy: 0}];
  }
}

function saveEnergyHistory(a){ 
  try{
    // Убеждаемся, что нулевая точка не сохраняется в localStorage
    const filtered = a.filter(item => item.energy !== 0 || item.ts !== new Date(0).toISOString());
    localStorage.setItem(ENERGY_HISTORY_KEY, JSON.stringify(filtered));
  } catch(e){} 
}

function addEnergyHistoryEntry(e){ 
  const d = new Date(); 
  d.setSeconds(0,0); 
  const h = loadEnergyHistory();
  // Пропускаем добавление, если пытаемся добавить нулевую точку
  if (e === 0) return;
  
  // Удаляем нулевую точку из начала перед добавлением новой записи
  const filtered = h.filter(item => item.energy !== 0 || item.ts !== new Date(0).toISOString());
  filtered.push({ts: d.toISOString(), energy: Number(e) || 0});
  saveEnergyHistory(filtered);
}

function loadEnergyHistoryMain(){ try{ const r = localStorage.getItem(ENERGY_HISTORY_MAIN_KEY); const parsed = r ? JSON.parse(r) : []; if (parsed.length === 0 || parsed[0].norm !== 0) {   const zeroPoint = {ts: new Date(0).toISOString(), norm: 0};   return [zeroPoint, ...parsed]; } return parsed;}catch(e){ return [{ts: new Date(0).toISOString(), norm: 0}];} }
function saveEnergyHistoryMain(a){ try{ const filtered = a.filter(item => item.norm !== 0 || item.ts !== new Date(0).toISOString()); localStorage.setItem(ENERGY_HISTORY_MAIN_KEY, JSON.stringify(filtered));}catch(e){} }
function _downsampleSeries(arr, maxPts){ const N = arr.length; if(N<=maxPts) return arr.slice(); const out=[]; for(let i=0;i<maxPts;i++){ const idx=Math.round(i*(N-1)/(maxPts-1)); out.push(arr[idx]); } return out; }
function addEnergyHistoryEntryMain(n){ const d=new Date(); d.setSeconds(0,0); const h=loadEnergyHistoryMain(); if (n === 0) return; const filtered = h.filter(item => item.norm !== 0 || item.ts !== new Date(0).toISOString()); filtered.push({ts:d.toISOString(), norm:Number(n)||0}); saveEnergyHistoryMain(filtered);}

function getNormalizationReference(){
  const h = loadEnergyHistory();
  // Пропускаем нулевую точку при поиске максимального значения
  const filtered = h.filter(item => item.energy !== 0 || item.ts !== new Date(0).toISOString());
  if(filtered.length === 0) return null; 
  let m = -Infinity; 
  for(const x of filtered){ const v = Number(x.energy) || 0; if(v > m) m = v; } 
  return (isFinite(m) && m > 0) ? m : null;
}

function drawEnergyHistory(){
  const mode=getMode(), isMain=(mode==='main');
  const _all = isMain?loadEnergyHistoryMain():loadEnergyHistory();
  // visual-only: keep arrays intact, hide leading zero marker
  const data = (Array.isArray(_all) && _all.length && (function(r){ try{ const ts0=r&&r.ts&&new Date(r.ts).getTime()===0; const v0=isMain?Number(r.norm)===0:Number(r.energy)===0; return ts0&&v0; }catch(_){return false;} })(_all[0])) ? _all.slice(1) : _all;
  hctx.clearRect(0,0,historyCanvas.width,historyCanvas.height);
  if(!data.length){hctx.fillStyle='#555'; hctx.font='14px Arial'; hctx.fillText(isMain?tr('statusHistEmptyMain'):tr('statusHistEmptyNorm'),20,30);return;}
  const vals=data.map(d=>isMain?(+d.norm||0):(+d.energy||0)); const maxV=Math.max(...vals)||1;
  const leftPad=50,bottomPad=28,rightPad=20,topPad=12; const W=historyCanvas.width-leftPad-rightPad,H=historyCanvas.height-topPad-bottomPad;
  
  try {
    if (isMain) {
      
      const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
      const yFromVal = (val) => { const y = topPad + H - (H * (val / (maxV || 1))); return clamp(y, topPad, topPad + H); };
      const y0   = yFromVal(0);
      const y05  = yFromVal(0.5);
      const y08  = yFromVal(0.8);
      const yTop = yFromVal(maxV); // extend up to current maximum
      hctx.fillStyle = 'rgba(255, 0, 0, 0.08)'; hctx.fillRect(leftPad, Math.min(y0, y05), W, Math.abs(y05 - y0));
      hctx.fillStyle = 'rgba(255, 215, 0, 0.10)'; hctx.fillRect(leftPad, Math.min(y05, y08), W, Math.abs(y08 - y05));
      hctx.fillStyle = 'rgba(0, 128, 0, 0.10)'; hctx.fillRect(leftPad, Math.min(y08, yTop), W, Math.abs(yTop - y08));
    
    }
  } catch(e) { }
  hctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--grid'); hctx.lineWidth=1;
  for(let i=0;i<=4;i++){const y=topPad+H-(H*i/4);hctx.beginPath();hctx.moveTo(leftPad,y);hctx.lineTo(leftPad+W,y);hctx.stroke();hctx.fillStyle='#555';hctx.font='11px Arial';const v=maxV*i/4;const lab=isMain?v.toFixed(2):v.toExponential(2);hctx.fillText(lab,6,y-2);
}
  hctx.strokeStyle='#000';hctx.beginPath();hctx.moveTo(leftPad,topPad);hctx.lineTo(leftPad,topPad+H);hctx.lineTo(leftPad+W,topPad+H);hctx.stroke();
  hctx.fillStyle='#000';hctx.font='12px Arial';hctx.fillText(tr('histX'),leftPad+W/2-60,topPad+H+22);hctx.save();hctx.rotate(-Math.PI/2);hctx.fillText(isMain?tr('histYNorm'):tr('histYAbs'),-topPad-H/2-80,15);hctx.restore();
  hctx.beginPath(); const N=data.length; for(let i=0;i<N;i++){const x=leftPad+(W*(i/Math.max(1,N-1))); const y=topPad+H-(H*(vals[i]/maxV)); if(i===0)hctx.moveTo(x,y); else hctx.lineTo(x,y);} hctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--green'); hctx.lineWidth=2; hctx.stroke();
  if (isMain) {
    hctx.beginPath();
    for (let i=0;i<N;i++){ const rec = data[i]||{}; if (typeof rec.cut==='number'){ const x = leftPad + (W*(i/Math.max(1,N-1))); const y = topPad + H - (H*((rec.cut/100)/maxV)); if (i === 0) hctx.moveTo(x, y); else hctx.lineTo(x, y); } }
    hctx.strokeStyle = '#ff0066'; hctx.lineWidth = 1.5; hctx.stroke();
    for (let i=0;i<N;i++){ const rec = data[i]||{}; if (typeof rec.cut==='number'){ const x = leftPad + (W*(i/Math.max(1,N-1))); const y = topPad + H - (H*((rec.cut/100)/maxV)); hctx.beginPath(); hctx.arc(x, y, 4, 0, Math.PI*2); hctx.fillStyle = '#ff0066'; hctx.fill(); } }
  
// Additional cut series for 0.25s, 0.5s, 0.75s, 1s
try{
  const drawCutSeries = (k)=>{
    let first=true; hctx.beginPath();
    for(let i=0;i<N;i++){
      const rec=data[i]||{}; if(rec && rec.cuts && rec.cuts[k]!=null){
        const xv=leftPad+(W*(i/Math.max(1,N-1))); const yv=topPad+H-(H*((Math.max(0,Math.min(100,Number(rec.cuts[k])))/100)/(maxV||1)));
        if(first){hctx.moveTo(xv,yv); first=false;} else {hctx.lineTo(xv,yv);} }
    }
    hctx.strokeStyle='#ff0066'; hctx.lineWidth=1.2; hctx.stroke();
    for(let i=0;i<N;i++){
      const rec=data[i]||{}; if(rec && rec.cuts && rec.cuts[k]!=null){
        const xv=leftPad+(W*(i/Math.max(1,N-1))); const yv=topPad+H-(H*((Math.max(0,Math.min(100,Number(rec.cuts[k])))/100)/(maxV||1)));
        hctx.beginPath(); hctx.arc(xv,yv,3.5,0,Math.PI*2); hctx.fillStyle='#ff0066'; hctx.fill(); }
    }
  };
  [0,1,2,3].forEach(drawCutSeries);
}catch(e){}
}
  hctx.fillStyle='#111';hctx.font='10px Arial';const step=1;
  for(let i=0;i<N;i++){const x=leftPad+(W*(i/Math.max(1,N-1))); const y=topPad+H-(H*(vals[i]/maxV)); hctx.beginPath();hctx.arc(x,y,2.5,0,Math.PI*2);hctx.fill(); if(i%step===0||i===N-1){const d=new Date(data[i].ts); const lab=d.toLocaleString(undefined,{month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit'});hctx.fillText(lab,x-32,topPad+H+14);}}
}

/* Remove last + auto-repeat */
function removeLastHistoryEntry(){
  const mode = getMode();
  if(mode === 'main'){ const h = loadEnergyHistoryMain(); const filtered = h.filter(item => item.norm !== 0 || item.ts !== new Date(0).toISOString()); if(!filtered.length){ setStatus(tr('statusHistEmptyMain'),'warn'); return; } filtered.pop(); saveEnergyHistoryMain(filtered); setStatus(tr('statusHistDelMain'),'ok'); } else {
    const h = loadEnergyHistory();
    // Не удаляем нулевую точку
    if(h.length <= 1){ setStatus(tr('statusHistEmptyNorm'),'warn'); return; }
    
    // Удаляем последнюю запись, но не нулевую точку
    const filtered = h.filter(item => item.energy !== 0 || item.ts !== new Date(0).toISOString());
    if(!filtered.length){ setStatus(tr('statusHistEmptyNorm'),'warn'); return; }
    filtered.pop();
    saveEnergyHistory(filtered);
    setStatus(tr('statusHistDelNorm'),'ok');
  }
  drawEnergyHistory();
}
if(btnResetLast) btnResetLast.addEventListener('click',removeLastHistoryEntry);
let _resetHoldTimer=null, _resetRepeatTimer=null; const _initialDelayMs=600, _repeatEveryMs=250;
function _startResetAutoRepeat(){ if(_resetHoldTimer||_resetRepeatTimer) return; _resetHoldTimer=setTimeout(()=>{ removeLastHistoryEntry(); _resetRepeatTimer=setInterval(removeLastHistoryEntry,_repeatEveryMs); }, _initialDelayMs); }
function _stopResetAutoRepeat(){ if(_resetHoldTimer){clearTimeout(_resetHoldTimer);_resetHoldTimer=null;} if(_resetRepeatTimer){clearInterval(_resetRepeatTimer);_resetRepeatTimer=null;} }
if(btnResetLast){ btnResetLast.addEventListener('mousedown',e=>{ if(e.button===0) _startResetAutoRepeat();}); window.addEventListener('mouseup',_stopResetAutoRepeat); btnResetLast.addEventListener('mouseleave',_stopResetAutoRepeat); btnResetLast.addEventListener('touchstart',e=>{e.preventDefault();_startResetAutoRepeat();},{passive:false}); window.addEventListener('touchend',_stopResetAutoRepeat); window.addEventListener('touchcancel',_stopResetAutoRepeat); btnResetLast.addEventListener('contextmenu',e=>e.preventDefault());}

/* Graph */
function mapValToY(val,minV,maxV){const h=canvas.height,p=(val-minV)/(maxV-minV||1);return(h-1)-p*(h-1);}
function drawGraph(intensityValues,secondSeries,isNorm=false){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  try{
    const totalTime = Math.max((typeof lastT!=='undefined' && typeof t0!=='undefined') ? (lastT - t0) : 0, 0);
    if (totalTime > 0.001){
      const secs = Math.floor(totalTime);
      const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--grid') || '#e9e9e9';
      ctx.strokeStyle = gridColor; ctx.lineWidth = 1; ctx.textAlign = 'center'; ctx.fillStyle = '#555'; ctx.font = '11px Arial';
      for (let s=0; s<=secs; s++){
        const x = (s / totalTime) * canvas.width;
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
        if (s % 5 === 0){ ctx.save(); ctx.lineWidth = 1.5; ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); ctx.restore(); }
        ctx.fillText(String(s), x, canvas.height - 6);
      }
      ctx.textAlign = 'left';
    }
  }catch(e){}
  let maxI=Math.max(...intensityValues)||1, maxS=Math.max(...secondSeries)||1;
  const maxIfs=maxI*1.05, maxSfs=maxS*1.1;
  ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--grid');
  for(let i=0;i<=5;i++){const y=mapValToY(maxIfs*i/5,0,maxIfs);ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(canvas.width,y);ctx.stroke();}
  ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--axes');ctx.beginPath();ctx.moveTo(0,canvas.height-1);ctx.lineTo(canvas.width,canvas.height-1);ctx.moveTo(0,0);ctx.lineTo(0,canvas.height);ctx.stroke();
  ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--text');ctx.font='12px Arial';ctx.textAlign='left';
  for(let i=0;i<=5;i++){const v=maxIfs*i/5,y=mapValToY(v,0,maxIfs);ctx.fillText(v.toExponential(2),5,y-3);}
  ctx.save();ctx.rotate(-Math.PI/2);ctx.fillText(tr('yLeft'),-canvas.height+10,14);ctx.restore();
  ctx.textAlign='right';
  for(let i=0;i<=5;i++){const v=maxSfs*i/5,y=mapValToY(v,0,maxSfs);ctx.fillText(isNorm?v.toFixed(2):v.toExponential(2),canvas.width-5,y-3);}
  ctx.save();ctx.rotate(Math.PI/2);ctx.fillText(isNorm?tr('yRightNorm'):tr('yRightRaw'),canvas.height/2-60,canvas.width-10);ctx.restore();
  ctx.beginPath(); for(let i=0;i<intensityValues.length;i++){const x=(i/Math.max(intensityValues.length-1,1))*canvas.width;const y=mapValToY(intensityValues[i],0,maxIfs);if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);} ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--blue');ctx.lineWidth=2;ctx.stroke();
  ctx.beginPath(); for(let i=0;i<secondSeries.length;i++){const x=(i/Math.max(secondSeries.length-1,1))*canvas.width;const y=mapValToY(secondSeries[i],0,maxSfs);if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);} ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--green');ctx.lineWidth=2;ctx.stroke();
  if (secondSeries.length>1){
    const last = secondSeries[secondSeries.length-1];
    const y = mapValToY(last, 0, maxSfs);
    ctx.beginPath(); ctx.setLineDash([5,3]); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y);
    ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--green-dark'); ctx.lineWidth=1; ctx.stroke(); ctx.setLineDash([]);
  }
  if (signalStartTime !== null) {
    const totalTime = lastT - t0;
    if (totalTime > 0) {
      const xStart = (signalStartTime / totalTime) * canvas.width;
      ctx.beginPath(); ctx.setLineDash([5, 3]); ctx.moveTo(xStart, 0); ctx.lineTo(xStart, canvas.height);
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--signal-start') || '#ff6b00'; ctx.lineWidth = 3; ctx.shadowBlur = 8; ctx.shadowColor = 'rgba(255,107,0,0.7)'; ctx.stroke(); ctx.setLineDash([]); ctx.shadowBlur = 0;
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--signal-start') || '#ff6b00'; ctx.font = 'bold 12px Arial'; ctx.fillText(tr('startLabel'), xStart + 5, 15);
    }
  }
  try {
    const mode = getMode();
    const refNow = getNormalizationReference();
    if (mode==='main' && !refNow && Array.isArray(cutTimesAbs) && cutTimesAbs.length) {
  const totalTime = lastT - t0;
  if (totalTime > 0) {
    const labels = ['+0.25с','+0.5с','+0.75с','+1с'];
    cutTimesAbs.forEach((ct,idx)=>{
      const xCut = (ct / totalTime) * canvas.width;
      ctx.beginPath(); ctx.setLineDash([4,4]); ctx.moveTo(xCut,0); ctx.lineTo(xCut,canvas.height);
      ctx.strokeStyle='#444'; ctx.lineWidth=2; ctx.stroke(); ctx.setLineDash([]);
      ctx.fillStyle='#333'; ctx.font='bold 12px Arial'; ctx.fillText(labels[idx]||('+'+((ct-signalStartTime).toFixed(2))+'с'), xCut+5, 45);
    });
  }
}
  } catch(e) {}
  if (signalEndTime !== null) {
    const totalTime = lastT - t0;
    if (totalTime > 0) {
      const xEnd = (signalEndTime / totalTime) * canvas.width;
      ctx.beginPath(); ctx.setLineDash([5, 3]); ctx.moveTo(xEnd, 0); ctx.lineTo(xEnd, canvas.height);
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--signal-end') || '#ff0066'; ctx.lineWidth = 3; ctx.shadowBlur = 8; ctx.shadowColor = 'rgba(255,0,102,0.7)'; ctx.stroke(); ctx.setLineDash([]); ctx.shadowBlur = 0;
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--signal-end') || '#ff0066'; ctx.font = 'bold 12px Arial'; ctx.fillText(tr('endLabel'), xEnd + 5, 30);
    }
  }
  if (currentThreshold > 0) {
    const yThreshold = mapValToY(currentThreshold, 0, maxIfs);
    ctx.beginPath(); ctx.setLineDash([3, 3]); ctx.moveTo(0, yThreshold); ctx.lineTo(canvas.width, yThreshold);
    ctx.strokeStyle = '#888'; ctx.lineWidth = 1; ctx.stroke(); ctx.setLineDash([]);
    ctx.fillStyle = '#666'; ctx.font = '10px Arial'; ctx.fillText(`Порог: ${currentThreshold.toExponential(2)}`, 10, yThreshold - 5);
  }
}

/* Mic */
async function requestMicrophoneAccess(){
  try{
    micStream=await navigator.mediaDevices.getUserMedia({audio:true});
    if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)();
    analyser=audioCtx.createAnalyser(); analyser.fftSize=2048; source=audioCtx.createMediaStreamSource(micStream); source.connect(analyser);
    setStatus(tr('statusMicOk'),'ok');
  }catch(e){ setStatus(tr('statusMicErr')+e.message,'error'); }
}

/* Recording */
let intensityValues=[], integralValues=[];
function rms(b){let a=0;for(let v of b)a+=v*v;return Math.sqrt(a/(b.length||1));}
function tick(){
  if(!recording) return;
  const buffer=new Float32Array(analyser.fftSize); analyser.getFloatTimeDomainData(buffer);
  const r=rms(buffer), intensity=(r*r) * (getSignalGain()**2);
  const t=audioCtx.currentTime, dt=Math.max(0,t-lastT); lastT=t;
  const relTime = t - t0; sampleTimes.push(relTime);
  const last=(integralValues.length?integralValues[integralValues.length-1]:0);
  const next=last+intensity*dt;
  intensityValues.push(intensity); integralValues.push(next);
  if (checkAutoStop(t)) { return; }
  const signalEvent = detectSignal(intensity, next, t);
  if (signalEvent === 'start') {
    cutTimesAbs = [signalStartTime+0.25, signalStartTime+0.5, signalStartTime+0.75, signalStartTime+1.0]; cutPointsPercent = [];
    setStatus('🔊 Обнаружено начало сигнала', 'ok');
  } else if (signalEvent === 'end') {
    setStatus('🔇 Обнаружен конец сигнала', 'ok');
  }
  updateSignalInfo();
  const mode=getMode();
  if(mode==='normalization'){
    drawGraph(intensityValues, integralValues, false);
  }else{
    const ref=getNormalizationReference();
    if(ref){
      const norm=integralValues.map(v=>v/ref);
      drawGraph(intensityValues, norm, true);
    }else{
      const lastNow = integralValues.length ? integralValues[integralValues.length-1] : 1;
      const norm=integralValues.map(v=>v/(lastNow||1));
      if (Array.isArray(cutTimesAbs) && cutTimesAbs.length && sampleTimes.length>0) {
  const series = norm;
  cutPointsPercent = cutTimesAbs.map(ct=>{
    let idx = sampleTimes.findIndex(tt => tt >= ct);
    if (idx === -1) idx = sampleTimes.length - 1;
    const val = series[Math.max(0, idx)] || 0;
    return Math.max(0, Math.min(100, val*100));
  });
}
      drawGraph(intensityValues, norm, true);
    }
  }
  rafId=requestAnimationFrame(tick);
}

function stopRecordingAndFinalize(){
  recording=false; if(rafId) { cancelAnimationFrame(rafId); rafId = null; }
  if (isSignalActive && signalStartTime !== null && signalEndTime === null) {
    signalEndTime = lastT - t0; updateSignalInfo();
  }
  const mode=getMode();
  if(mode==='normalization'){
    const last=integralValues.length?integralValues[integralValues.length-1]:0;
    addEnergyHistoryEntry(last);
    setStatus(tr('statusNormOn'),'warn');
  }else{
    const ref=getNormalizationReference();
    const last=integralValues.length?integralValues[integralValues.length-1]:0;
    const norm=ref ? (last/ref) : 1;
    if (!ref) {
      const lastNow = last||1;
      const normSeries = integralValues.map(v=>v/(lastNow||1));
      const ds = _downsampleSeries(normSeries, 200);
      let cutsArr = [];
if(Array.isArray(cutTimesAbs) && cutTimesAbs.length && sampleTimes.length>0){
  const series = normSeries;
  cutsArr = cutTimesAbs.map(ct=>{
    let idx = sampleTimes.findIndex(tt => tt >= ct);
    if(idx === -1) idx = sampleTimes.length-1;
    const v = series[Math.max(0, idx)] || 0;
    return Math.max(0, Math.min(100, v*100));
  });
}
const d = new Date(); d.setSeconds(0,0);
      const h = loadEnergyHistoryMain();
      h.push({ts:d.toISOString(), norm:Number(norm)||0, cuts:cutsArr, series:ds});
      saveEnergyHistoryMain(h);
    } else {
      addEnergyHistoryEntryMain(norm);
    }
    setStatus(tr('statusMainDone'),'ok');
  }
  drawEnergyHistory();
  hideLowIntensityWarning();
}

/* Reset */
function resetRecording(){
  recording=false; t0=0; lastT=0; intensityValues=[]; integralValues=[]; sampleTimes=[]; cutTimesAbs=[]; cutPointsPercent=[];
  signalStartTime = null; signalEndTime = null; isSignalActive = false; maxIntensity = 0; lastIntegralValue = 0; stableCount = 0; currentThreshold = 0;
  if(rafId) { cancelAnimationFrame(rafId); rafId = null; }
  updateSignalInfo(); setThresholdInfo('Current threshold: —');
  ctx.clearRect(0,0,canvas.width,canvas.height);
  setStatus(tr('statusReset'),'ok'); hideLowIntensityWarning();
}

/* Init */
function initI18n(){
  const sel=document.getElementById('langSelect'); if(!sel) return;
  const saved=localStorage.getItem(LANG_KEY)||'ru';
  sel.value=saved; applyTranslations(saved);
  sel.addEventListener('change',e=>{ applyTranslations(e.target.value); try{ drawEnergyHistory(); }catch(_){}});
}
function init(){
  try{ requestMicrophoneAccess(); }catch(_){}

  initI18n(); applyMode();
  const slider = document.getElementById('thrSlider');
  const out = document.getElementById('thrValue');
  const s2 = document.getElementById('stabSlider');
  const o2 = document.getElementById('stabValue');
  if(btnRequestMic) btnRequestMic.addEventListener('click',requestMicrophoneAccess);
  if(btnStart) btnStart.addEventListener('click', async ()=>{  try{ if(!analyser){ await requestMicrophoneAccess(); } }catch(_){ }  if(!analyser){ setStatus('Сначала разрешите микрофон.','error'); return; }  resetRecording(); recording=true; t0=audioCtx.currentTime; lastT=t0;  setStatus(tr('statusRec'),'ok'); tick();});
  if(btnStop) btnStop.addEventListener('click',stopRecordingAndFinalize);
  if(btnReset) btnReset.addEventListener('click',resetRecording);
  if(btnStartNorm) btnStartNorm.addEventListener('click',()=>setMode('normalization'));
  if(btnFinishNorm) btnFinishNorm.addEventListener('click',()=>setMode('main'));
  if(btnTech) btnTech.addEventListener('click', openTech);
  if(btnCloseTech) btnCloseTech.addEventListener('click', ()=>{ closeTech(); });
  const btnCloseTechTop=document.getElementById('btnCloseTechTop');
  if(btnCloseTechTop) btnCloseTechTop.addEventListener('click', ()=>{ closeTech(); });
  if(techModal){
    techModal.addEventListener('click', closeTech);
    window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeTech(); });
  }
  // Initialize threshold slider (technical modal)
  try{
    if (slider && out){
      const pct = getThresholdPct();
      slider.value = String(pct);
      out.textContent = pct.toFixed(1) + '%';
      slider.addEventListener('input', (e)=>{
        const v = parseFloat(e.target.value);
        setThresholdPct(v);
        out.textContent = v.toFixed(1) + '%';
        const rel = Math.max(maxIntensity * getRelativeThresholdFraction(), ABSOLUTE_FLOOR);
        setThresholdInfo(`Current threshold: ${rel.toExponential(2)} (${getThresholdPct().toFixed(1)}% of max ${maxIntensity>0?maxIntensity.toExponential(2):'—'})`);
      });
    }
  }catch(e){}
  // Initialize stability slider (technical modal)
  try{
    if (s2 && o2){
      const pct2 = getStabilityPct();
      s2.value = String(pct2);
      o2.textContent = pct2.toFixed(2) + '%';
      s2.addEventListener('input', (e)=>{
        const v = parseFloat(e.target.value);
        setStabilityPct(v);
        o2.textContent = v.toFixed(2) + '%';
      });
    }
  }catch(e){} 
  
  // Initialize signal gain slider (technical modal)
  try{
    const gSlider = document.getElementById('gainSlider');
    const gOut = document.getElementById('gainValue');
    if (gSlider && gOut){
      const gs = getSignalGain();
      gSlider.value = String(gs.toFixed(1));
      gOut.textContent = '×'+gs.toFixed(1);
      gSlider.addEventListener('input', (e)=>{
        const v = setSignalGain(parseFloat(e.target.value));
        gOut.textContent = '×'+v.toFixed(1);
      });
    }
  }catch(e){} 
drawEnergyHistory();
  // Ensure modal is English at startup:
  try{
    const tt=document.getElementById('techTitle'); if(tt) tt.textContent='Technical settings';
    const bc=document.getElementById('btnCloseTech'); if(bc) bc.textContent='Close';
    const bcTop=document.getElementById('btnCloseTechTop'); if(bcTop) bcTop.textContent='Close';
    const ti=document.getElementById('thresholdInfo'); if(ti && (ti.textContent.trim()===''||ti.textContent.includes('—'))) ti.textContent='Current threshold: —';
  }catch(e){}
}
window.addEventListener('load',init);
</script>
<script>
/* ===== HTML-only export (tolerant if one history is empty) =====
   - Always exports, even if normalization or main history is empty
   - Embeds data into report (no dependency on localStorage)
   - Energy chart uses P95 auto-clip; energy table uses scientific notation
*/
(function(){
  function percentile(a,p){a=a.slice().filter(v=>isFinite(v)).sort((x,y)=>x-y);if(!a.length)return 0;const i=(p/100)*(a.length-1);const lo=Math.floor(i),hi=Math.ceil(i);if(lo===hi)return a[lo];const w=i-lo;return a[lo]*(1-w)+a[hi]*w;}
  function niceNum(r,round){const e=Math.floor(Math.log10(r||1)),f=(r/Math.pow(10,e))||1;let nf;if(round){if(f<1.5)nf=1;else if(f<3)nf=2;else if(f<7)nf=5;else nf=10;}else{if(f<=1)nf=1;else if(f<=2)nf=2;else if(f<=5)nf=5;else nf=10;}return nf*Math.pow(10,e);}
  function niceAxis(a,b,n){if(a===b){b=a+1;}const rg=niceNum(b-a,false),st=niceNum(rg/(n-1),true),g0=Math.floor(a/st)*st,g1=Math.ceil(b/st)*st;const t=[];for(let v=g0;v<=g1+0.5*st;v+=st)t.push(v);return{min:g0,max:g1,step:st,ticks:t};}
  function tryParseJSON(s){ try{ return JSON.parse(s);}catch(_){ return null; } }

  function collectFromLocalStorage(){
    let bestNorm=[], bestMain=[];
    for(let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      const val = tryParseJSON(localStorage.getItem(k));
      if(Array.isArray(val) && val.length){
        const sample = val[0]||{};
        if('energy' in sample){ if(val.length>bestNorm.length) bestNorm = val; }
        if('norm' in sample || 'normalized' in sample){ if(val.length>bestMain.length) bestMain = val; }
      }
    }
    bestMain = bestMain.map(r=>({ts:r.ts||r.time||r.date||new Date().toISOString(), norm:('norm' in r)?r.norm:(r.normalized||null), cut:r.cut}));
    bestNorm = bestNorm.map(r=>({ts:r.ts||r.time||r.date||new Date().toISOString(), energy:r.energy}));
    return {normHist:bestNorm||[], mainHist:bestMain||[]};
  }

  function collectHistories(){
    let normHist = [], mainHist = [];
    try{ if(typeof loadEnergyHistory==='function'){ normHist = loadEnergyHistory() || []; } }catch(_){}
    try{ if(typeof loadEnergyHistoryMain==='function'){ mainHist = loadEnergyHistoryMain() || []; } }catch(_){}
    if(!(normHist && normHist.length) || !(mainHist && mainHist.length)){
      const r = collectFromLocalStorage();
      if(!normHist.length) normHist = r.normHist;
      if(!mainHist.length) mainHist = r.mainHist;
    }
    // ensure arrays even if empty
    return {normHist: Array.isArray(normHist)?normHist:[], mainHist: Array.isArray(mainHist)?mainHist:[]};
  }

  
  // --- Safe wrapper to avoid silent failures on Share click ---
  function exportHTMLReportSafe(){
    try { return exportHTMLReport(); }
    catch(e){
      console.error('exportHTMLReport failed:', e);
      try{
        // Minimal fallback: empty report with error note
        const html='<!DOCTYPE html><html><head><meta charset="utf-8"><title>Acoustic Share Report (fallback)</title></head><body>' +
                   '<h1>Acoustic Share Report</h1><p>Fallback used due to error.</p></body></html>';
        const blob=new Blob([html],{type:'text/html;charset=utf-8'});
        const url=URL.createObjectURL(blob);
        const a=document.createElement('a'); a.href=url;
        const stamp=new Date().toISOString().replace(/[:.]/g,'-').slice(0,19);
        a.download='acoustic_share_'+stamp+'.html'; document.body.appendChild(a); a.click();
        setTimeout(()=>{URL.revokeObjectURL(url); a.remove();},0);
      }catch(_){ /* swallow */ }
    }
  }
function exportHTMLReport(){
    const {normHist, mainHist} = collectHistories();

    // --- Export safety normalization (fields + drop leading zero) ---
    const normHistN = (Array.isArray(normHist)?normHist:[]).map(r=>({ 
      ts: r.ts||r.time||r.date||new Date(0).toISOString(), 
      energy: (r.energy!=null)?Number(r.energy):(r.E!=null?Number(r.E):0)
    }));
    const mainHistN = (Array.isArray(mainHist)?mainHist:[]).map(r=>({ 
      ts: r.ts||r.time||r.date||new Date(0).toISOString(), 
      norm: (r.norm!=null)?Number(r.norm):((r.normalized!=null)?Number(r.normalized):(r.value!=null?Number(r.value):(r.val!=null?Number(r.val):0))),
      cuts: Array.isArray(r.cuts)? r.cuts : (r.cut!=null? [r.cut]: [])
    }));
    const isZeroRow=(row,isMain)=>{ try{ const ts0=row&&row.ts&&new Date(row.ts).getTime()===0;
      const v0=isMain? (Number(row.norm)===0) : (Number(row.energy)===0); return ts0&&v0; }catch(_){ return false; } };
    const normHistClean = (normHistN.length && isZeroRow(normHistN[0],false)) ? normHistN.slice(1) : normHistN;
    const mainHistClean = (mainHistN.length && isZeroRow(mainHistN[0],true)) ? mainHistN.slice(1) : mainHistN;

    const norm = JSON.stringify(normHist).replace(/</g,'\\u003C');
    const main = JSON.stringify(mainHist).replace(/</g,'\\u003C');
    const lang = (localStorage.getItem(LANG_KEY) || 'ru');
    const parts = [];
    parts.push('<!DOCTYPE html><html lang="'+lang+'"><head><meta charset="UTF-8"><title>'+trSafe('reportWindowTitle','Acoustic Share Report')+'</title>');
    parts.push('<meta name="viewport" content="width=device-width, initial-scale=1">');
    parts.push('<style>body{font-family:Arial,sans-serif;margin:20px;}h1{font-size:20px;margin:0 0 6px 0;}h2{font-size:16px;margin:14px 0 6px 0;}canvas{border:1px solid #ddd;border-radius:6px;width:100%;height:260px;}table{border-collapse:collapse;width:100%;font-size:12px;}th,td{border:1px solid #ccc;padding:6px 8px;}th{background:#f5f5f5;}.grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;align-items:start;}.legend{display:flex;gap:14px;align-items:center;margin:6px 0 2px 0;font-size:12px;color:#333}.chip{width:12px;height:12px;border-radius:2px;display:inline-block;border:1px solid #999}.c-energy{background:#cfe8ff;border-color:#6aa0ff}.c-norm{background:#d7f5e3;border-color:#42a362}.c-cut{background:#ffd7e8;border-color:#ff66a3}.bg-red{background:rgba(255,0,0,0.08)}.bg-yellow{background:rgba(255,215,0,0.10)}.bg-green{background:rgba(0,128,0,0.10)}.card{border:1px solid #ddd;border-radius:10px;padding:12px;margin:10px 0;}.note{margin:8px 0 0 2px;color:#666;font-size:12px;}</style>');
    parts.push('</head><body>');
    parts.push('<h1>'+trSafe('reportTitle','Акустический спироанализатор — отчёт')+'</h1>');
    parts.push('<div>'+trSafe('reportDate','Дата формирования:')+' '+ new Date().toLocaleString() + '</div>');

    parts.push('<div class="card"><h2>'+trSafe('sectionNorm','История нормирования')+'</h2>');
    parts.push('<div class="legend"><span class="chip c-energy"></span> '+trSafe('legendEnergy','Интегральная энергия')+'</div>');
    parts.push('<div class="grid"><canvas id="cnNorm" width="800" height="260"></canvas>');
    parts.push('<div><table><thead><tr><th>#</th><th>'+trSafe('timeLabel','Время')+'</th><th>'+trSafe('energySciLabel','Energy (sci)')+'</th></tr></thead><tbody id="tbNorm"></tbody></table>');
    parts.push('<div class="note" id="noteNorm"></div></div></div></div>');

    parts.push('<div class="card"><h2>'+trSafe('sectionMain','История основного режима')+'</h2>');
    parts.push('<div class="legend"><span class="chip c-norm"></span> '+trSafe('legendNorm','Нормированная асимптота')+' <span class="chip c-cut"></span> '+trSafe('legendCut','Точка отсечения')+'</div>');
    parts.push('<div class="grid"><canvas id="cnMain" width="800" height="260"></canvas>');
    parts.push('<div><table><thead><tr><th>#</th><th>'+trSafe('timeLabel','Время')+'</th><th>'+trSafe('normLabel','Norm')+'</th><th>+0.25 '+trSafe('secUnit','с')+'</th><th>+0.50 '+trSafe('secUnit','с')+'</th><th>+0.75 '+trSafe('secUnit','с')+'</th><th>+1.00 '+trSafe('secUnit','с')+'</th></tr></thead><tbody id="tbMain"></tbody></table>');
    parts.push('<div class="note" id="noteMain"></div></div></div></div>');
parts.push('<script>');
    // Helper to renumber table rows starting from 1 (only inside the report)
    parts.push('function renumber(tid){ try{ var tb=document.getElementById(tid); if(!tb) return; var rs=tb.rows; for(var i=0;i<rs.length;i++){ if(rs[i].cells && rs[i].cells.length){ rs[i].cells[0].textContent=String(i+1); } } }catch(_){}}');

    parts.push('const dataNorm = ' + norm + '; const dataMain = ' + main + ';');
    // Localized "no data" string for report canvas
    const __NO_DATA = trSafe('noData','Нет данных');
    parts.push('const NO_DATA = ' + JSON.stringify(__NO_DATA) + ';');

    parts.push(`
function percentile(a,p){a=a.slice().filter(v=>isFinite(v)).sort((x,y)=>x-y);if(!a.length)return 0;const i=(p/100)*(a.length-1);const lo=Math.floor(i),hi=Math.ceil(i);if(lo===hi)return a[lo];const w=i-lo;return a[lo]*(1-w)+a[hi]*w;}
function niceNum(r,round){const e=Math.floor(Math.log10(r||1)),f=(r/Math.pow(10,e))||1;let nf;if(round){if(f<1.5)nf=1;else if(f<3)nf=2;else if(f<7)nf=5;else nf=10;}else{if(f<=1)nf=1;else if(f<=2)nf=2;else if(f<=5)nf=5;else nf=10;}return nf*Math.pow(10,e);}
function niceAxis(a,b,n){if(a===b){b=a+1;}const rg=niceNum(b-a,false),st=niceNum(rg/(n-1),true),g0=Math.floor(a/st)*st,g1=Math.ceil(b/st)*st;const t=[];for(let v=g0;v<=g1+0.5*st;v+=st)t.push(v);return{min:g0,max:g1,step:st,ticks:t};}
function drawHistory(canvasId, rows, isMain){
const c = document.getElementById(canvasId), x = c.getContext('2d');
  const left=50, right=20, top=12, bottom=28, W=c.width-left-right, H=c.height-top-bottom;
  x.clearRect(0,0,c.width,c.height);
  if(!rows || !rows.length){ x.fillStyle='#555'; x.font='14px Arial'; x.fillText(NO_DATA,20,30); return; }
  const vals = rows.map(r=> isMain ? (+r.norm||0) : (+r.energy||0) );
  const maxCandidate = isMain ? Math.max.apply(null, vals.concat([1])) : Math.max(percentile(vals,95), 1e-12);
  const ax = niceAxis(0, maxCandidate, 6);
  x.strokeStyle='#e9e9e9'; x.lineWidth=1;
  ax.ticks.forEach(v=>{const y=top+H-(H*((v-ax.min)/(ax.max-ax.min||1)));x.beginPath();x.moveTo(left,y);x.lineTo(left+W,y);x.stroke();});
  x.strokeStyle='#000'; x.beginPath(); x.moveTo(left,top); x.lineTo(left,top+H); x.lineTo(left+W,top+H); x.stroke();
  x.fillStyle='#111'; x.font='11px Arial';
  ax.ticks.forEach(v=>{ const y=top+H-(H*((v-ax.min)/(ax.max-ax.min||1))); const lab=isMain?v.toFixed(2):(v===0?'0':Number(v).toExponential(2)); x.fillText(lab,6,y-2); });
  if (isMain){
const yFromVal=(val)=> top+H-(H*((val-ax.min)/(ax.max-ax.min||1)));
    const y0=yFromVal(0), y05=yFromVal(0.5), y08=yFromVal(0.8), yTop=yFromVal(ax.max);
    x.fillStyle='rgba(255,0,0,0.08)';   x.fillRect(left, Math.min(y0,y05), W, Math.abs(y05-y0));
    x.fillStyle='rgba(255,215,0,0.10)'; x.fillRect(left, Math.min(y05,y08), W, Math.abs(y08-y05));
    x.fillStyle='rgba(0,128,0,0.10)';   x.fillRect(left, Math.min(y08,yTop), W, Math.abs(yTop-y08));
  }
x.fillStyle='#111'; x.font='10px Arial'; const N=rows.length, step=Math.ceil(N/8);
  for(let i=0;i<N;i++){ const xv=left+(W*(i/Math.max(1,N-1))); if(i%step===0||i===N-1){ const d=new Date(rows[i].ts); const lab=d.toLocaleString(undefined,{month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit'}); x.fillText(lab, xv-32, top+H+14); } }
  x.beginPath();
  for(let i=0;i<N;i++){ const xv=left+(W*(i/Math.max(1,N-1))); const yv=top+H-(H*((vals[i]-ax.min)/(ax.max-ax.min||1))); if(i===0) x.moveTo(xv,yv); else x.lineTo(xv,yv); }
  x.strokeStyle=isMain?'#1aab55':'#2f6fed'; x.lineWidth=2; x.stroke();
if(isMain){
  const drawCut=function(k){
    x.beginPath(); let first=true;
    for(let i=0;i<N;i++){
      const rec=rows[i]||{}; if(rec.cuts && rec.cuts[k]!=null){
        const xv=left+(W*(i/Math.max(1,N-1)));
        const yv=top+H-(H*((Math.max(0,Math.min(100,Number(rec.cuts[k])))/100)/(ax.max||1)));
        if(first){ x.moveTo(xv,yv); first=false; } else { x.lineTo(xv,yv); }
      }
    }
    x.strokeStyle='#ff0066'; x.lineWidth=1.4; x.stroke();
    for(let i=0;i<N;i++){
      const rec=rows[i]||{}; if(rec.cuts && rec.cuts[k]!=null){
        const xv=left+(W*(i/Math.max(1,N-1)));
        const yv=top+H-(H*((Math.max(0,Math.min(100,Number(rec.cuts[k])))/100)/(ax.max||1)));
        x.beginPath(); x.arc(xv,yv,3.5,0,Math.PI*2); x.fillStyle='#ff0066'; x.fill();
      }
    }
  };
  [0,1,2,3].forEach(drawCut);
}

  if(isMain){
    x.beginPath(); let started=false;
    for(let i=0;i<N;i++){ const rec=rows[i]||{}; if(typeof rec.cut==='number'){ const xv=left+(W*(i/Math.max(1,N-1))); const yv=top+H-(H*(( (rec.cut/100)-ax.min)/(ax.max-ax.min||1))); if(!started){ x.moveTo(xv,yv); started=true; } else x.lineTo(xv,yv); } }
    if(started){ x.strokeStyle='#ff0066'; x.lineWidth=1.5; x.stroke(); }
    for(let i=0;i<N;i++){ const rec=rows[i]||{}; if(typeof rec.cut==='number'){ const xv=left+(W*(i/Math.max(1,N-1))); const yv=top+H-(H*(( (rec.cut/100)-ax.min)/(ax.max-ax.min||1))); x.beginPath(); x.arc(xv,yv,3.5,0,Math.PI*2); x.fillStyle='#ff0066'; x.fill(); } }
  }
}
function fillTableNorm(tid, rows){
  const tb=document.getElementById(tid); tb.innerHTML='';
  if(!rows.length){ document.getElementById('noteNorm').textContent='Нет данных нормирования.'; return; }
  rows.forEach((r,i)=>{ const tr=document.createElement('tr'); const ts = new Date(r.ts).toLocaleString(); const en = (r.energy!=null)?((Number(r.energy)===0)?'0':Number(r.energy).toExponential(3).replace('e','×10^')):''; [i, ts, en].forEach(val=>{ const td=document.createElement('td'); td.textContent=String(val); tr.appendChild(td); }); tb.appendChild(tr); });
}
function fillTableMain(tid, rows){
  const tb=document.getElementById(tid); tb.innerHTML='';
  if(!rows.length){ document.getElementById('noteMain').textContent='Нет данных основного режима.'; return; }
  rows.forEach((r,i)=>{ const tr=document.createElement('tr'); const cells=[i, new Date(r.ts).toLocaleString(), (r.norm!=null)?Number(r.norm).toFixed(3):'', (r.cuts && r.cuts.length? Number(r.cuts[0]??'').toFixed(1):'') ,
 (r.cuts && r.cuts.length? Number(r.cuts[1]??'').toFixed(1):'') ,
 (r.cuts && r.cuts.length? Number(r.cuts[2]??'').toFixed(1):'') ,
 (r.cuts && r.cuts.length? Number(r.cuts[3]??'').toFixed(1):'') ]; cells.forEach(val=>{ const td=document.createElement('td'); td.textContent=String(val); tr.appendChild(td); }); tb.appendChild(tr); });
}
(function(){
  const normRows = Array.isArray(dataNorm)?dataNorm:[];
  const mainRows = Array.isArray(dataMain)?dataMain:[];
  const isZero=(r,isMain)=>{ try{ const ts0=r&&r.ts&&new Date(r.ts).getTime()===0; const v0=isMain?Number(r.norm)===0:Number(r.energy)===0; return ts0&&v0; }catch(_){ return false; } };
  const normVis = (normRows.length && isZero(normRows[0],false)) ? normRows.slice(1) : normRows;
  const mainVis = (mainRows.length && isZero(mainRows[0],true))  ? mainRows.slice(1) : mainRows;
  drawHistory('cnNorm', normVis, false);
  fillTableNorm('tbNorm', normVis); renumber('tbNorm');
  drawHistory('cnMain', mainVis, true);
  fillTableMain('tbMain', mainVis); renumber('tbMain');
})();`);
    parts.push('<\/script>');
    parts.push('</body></html>');

    const blob = new Blob([parts.join("")], {type:'text/html;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url;
    const stamp=new Date().toISOString().replace(/[:.]/g,'-').slice(0,19);
    a.download = 'acoustic_share_'+stamp+'.html';
    document.body.appendChild(a); a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
  }

  function ensureShareButton(){
    const target = document.getElementById('btnTech')?.parentElement || document.querySelector('.toolbar') || document.body;
    const btn = document.createElement('button');
    btn.id = 'btnShare';
    btn.className = 'button';
    btn.textContent = (currLang()==='en' ? 'Share' : (currLang()==='he' ? 'שתף' : 'Поделиться'));
    btn.addEventListener('click', exportHTMLReportSafe);
    target.appendChild(btn);
  }
  if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', ensureShareButton); }
  else { ensureShareButton(); }
})();

</script>
</body>
</html>