<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>Акустический анализ — Нормирование / Основной режим</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --grid:#e9e9e9;
    --axes:#222;
    --text:#111;
    --blue:#2f6fed;
    --green:#1aab55;
    --green-dark:#0f6e35;
    --warn:#b15d00;
    --ok:#0a7a2e;
    --error:#b00020;
  }
  body{font-family:Arial, sans-serif; margin:0; background:#fff; color:#111;}
  header{padding:10px 12px; border-bottom:1px solid #ddd; background:#fafafa}
  h1{font-size:18px; margin:4px 0;}
  main{padding:8px 0 18px;}
  .toolbar{display:flex; gap:8px; flex-wrap:wrap; margin:8px 12px;}
  .button{padding:8px 14px; border-radius:8px; border:1px solid #ccc; cursor:pointer; background:#f5f5f5}
  .button.primary{background:#2f6fed; border-color:#2f6fed; color:#fff}
  .button.alt{background:#fbe9e7; border-color:#f5ccbd; color:#5d2a00}
  .button:disabled{opacity:0.5; cursor:not-allowed}
  #modeBadge{margin-left:auto; font-size:12px; padding:4px 8px; border-radius:999px; background:#eef; color:#223;}
  body[data-mode="normalization"] #modeBadge{background:#fff6d6; color:#6b4e00;}
  body[data-mode="main"] #modeBadge{background:#e6ffe7; color:#0a5c10;}
  .row{display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin:0 12px;}
  .card{border:1px solid #ddd; border-radius:10px; padding:10px 12px; background:#fff;}
  .status{margin:8px 12px; font-size:14px;}
  .status.ok{color:var(--ok)} .status.warn{color:var(--warn)} .status.error{color:var(--error)}
  canvas{border:1px solid #ddd; border-radius:6px; margin:8px 12px;}
  .hint{font-size:12px; color:#555; margin:0 12px 12px;}
</style>
</head>
<body>
<header>
  <h1>Акустический анализ — Этап 1: «Нормирование» → Этап 2: «Основной анализ»</h1>
</header>

<main>
  <!-- Панель режимов -->
  <div class="toolbar" id="normToolbar">
    <button id="btnStartNorm" class="button">Начать нормирование</button>
    <button id="btnFinishNorm" class="button primary">Закончить нормирование</button>
    <span id="modeBadge">Режим: —</span>
  </div>

  <!-- Управление записью -->
  <div class="toolbar">
    <button id="btnRequestMic" class="button alt">Разрешить доступ к микрофону</button>
    <button id="btnStart" class="button">Начать запись</button>
    <button id="btnStop" class="button">Остановить</button>
    <button id="btnReset" class="button">Сброс</button>
  </div>

  <div class="status" id="status">Готов.</div>

  <!-- Основной график -->
  <canvas id="mainGraph" width="980" height="320"></canvas>

  <!-- История текущего режима -->
  <section id="historySection" class="card" style="margin:8px 12px;">
    <h3 style="margin:0 0 6px 0;">История результатов текущего режима</h3>
    <canvas id="historyGraph" width="980" height="240"></canvas>
    <div class="hint">В режиме нормирования — абсолютные асимптоты энергии (Вт·с/м²). В основном режиме — нормированные асимптоты (безразмерные, могут быть &gt;1 или &lt;1).</div>
  </section>
</main>

<script>
// ======== Глобальные переменные ========
let audioCtx = null;
let micStream = null;
let analyser = null;
let source = null;
let rafId = null;
let recording = false;
let t0 = 0;
let lastT = 0;

const MODE_KEY = 'analysisModeV1'; // 'normalization' | 'main'
const ENERGY_HISTORY_KEY = 'energyHistoryV1'; // нормирование: абсолютные энергии
const ENERGY_HISTORY_MAIN_KEY = 'energyHistoryMainV1'; // основной режим: нормированные асимптоты

const modeBadge = document.getElementById('modeBadge');
const statusEl = document.getElementById('status');
const canvas = document.getElementById('mainGraph');
const ctx = canvas.getContext('2d');
const historyCanvas = document.getElementById('historyGraph');
const hctx = historyCanvas.getContext('2d');

const btnRequestMic = document.getElementById('btnRequestMic');
const btnStart = document.getElementById('btnStart');
const btnStop = document.getElementById('btnStop');
const btnReset = document.getElementById('btnReset');
const btnStartNorm = document.getElementById('btnStartNorm');
const btnFinishNorm = document.getElementById('btnFinishNorm');

// ======== Утилиты статуса ========
function setStatus(msg, level='ok'){
  statusEl.className = 'status ' + (level||'ok');
  statusEl.textContent = msg;
}

// ======== Режимы ========
function getMode(){
  const v = localStorage.getItem(MODE_KEY);
  return (v==='main' || v==='normalization') ? v : 'normalization';
}
function setMode(v){
  localStorage.setItem(MODE_KEY, v);
  applyMode();
}
function applyMode(){
  const mode = getMode();
  document.body.setAttribute('data-mode', mode);
  modeBadge.textContent = 'Режим: ' + (mode==='normalization' ? 'Нормирование' : 'Основной анализ');
  drawEnergyHistory(); // перерисовать историю соответствующую режиму
}

// ======== Истории ========
function loadEnergyHistory(){
  try{ const raw = localStorage.getItem(ENERGY_HISTORY_KEY); return raw? JSON.parse(raw): []; }catch{return []}
}
function saveEnergyHistory(arr){
  try{ localStorage.setItem(ENERGY_HISTORY_KEY, JSON.stringify(arr)); }catch{}
}
function addEnergyHistoryEntry(energy){ // абсолютная
  const d = new Date(); d.setSeconds(0,0);
  const hist = loadEnergyHistory();
  hist.push({ ts: d.toISOString(), energy: Number(energy)||0 });
  saveEnergyHistory(hist);
}

function loadEnergyHistoryMain(){
  try{ const raw = localStorage.getItem(ENERGY_HISTORY_MAIN_KEY); return raw? JSON.parse(raw): []; }catch{return []}
}
function saveEnergyHistoryMain(arr){
  try{ localStorage.setItem(ENERGY_HISTORY_MAIN_KEY, JSON.stringify(arr)); }catch{}
}
function addEnergyHistoryEntryMain(normVal){ // нормированная
  const d = new Date(); d.setSeconds(0,0);
  const hist = loadEnergyHistoryMain();
  hist.push({ ts: d.toISOString(), norm: Number(normVal)||0 });
  saveEnergyHistoryMain(hist);
}

// Эталон для нормировки — максимум из истории нормирования
function getNormalizationReference(){
  const hist = loadEnergyHistory();
  if (!hist.length) return null;
  let maxV = -Infinity;
  for (const h of hist){
    const v = Number(h.energy) || 0;
    if (v > maxV) maxV = v;
  }
  return (isFinite(maxV) && maxV>0) ? maxV : null;
}

// ======== График истории текущего режима ========
function drawEnergyHistory(){
  const mode = getMode();
  const isMain = (mode==='main');
  const data = isMain ? loadEnergyHistoryMain() : loadEnergyHistory();
  hctx.clearRect(0,0,historyCanvas.width, historyCanvas.height);
  if (!data.length){
    hctx.fillStyle='#555'; hctx.font='14px Arial';
    hctx.fillText(isMain? 'История основного режима пуста.' : 'История нормирования пуста.', 20, 30);
    return;
  }
  const values = data.map(d => isMain ? (Number(d.norm)||0) : (Number(d.energy)||0));
  const maxV = Math.max(...values) || 1;
  const leftPad=50, bottomPad=28, rightPad=20, topPad=12;
  const W = historyCanvas.width - leftPad - rightPad;
  const H = historyCanvas.height - topPad - bottomPad;

  // сетка Y
  hctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');
  hctx.lineWidth = 1;
  const steps = 4;
  for (let i=0;i<=steps;i++){
    const y = topPad + H - (H*i/steps);
    hctx.beginPath(); hctx.moveTo(leftPad,y); hctx.lineTo(leftPad+W, y); hctx.stroke();
    hctx.fillStyle='#555'; hctx.font='11px Arial';
    const val = (maxV*i/steps);
    const label = isMain ? val.toFixed(2) : val.toExponential(2);
    hctx.fillText(label, 6, y-2);
  }
  // оси
  hctx.strokeStyle='#000';
  hctx.beginPath(); hctx.moveTo(leftPad,topPad); hctx.lineTo(leftPad,topPad+H); hctx.lineTo(leftPad+W,topPad+H); hctx.stroke();

  // подписи осей
  hctx.fillStyle='#000'; hctx.font='12px Arial';
  hctx.fillText('№ сеанса / время', leftPad+W/2-60, topPad+H+22);
  hctx.save(); hctx.rotate(-Math.PI/2);
  hctx.fillText(isMain? 'Нормированная асимптота (отн.)' : 'Интегральная энергия (Вт·с/м²)', -topPad-H/2-80, 15);
  hctx.restore();

  // линия
  hctx.beginPath();
  const N = data.length;
  for (let i=0;i<N;i++){
    const x = leftPad + (W*(i/Math.max(1, N-1)));
    const y = topPad + H - (H*(values[i]/maxV));
    if (i===0) hctx.moveTo(x,y); else hctx.lineTo(x,y);
  }
  hctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--green'); hctx.lineWidth=2; hctx.stroke();

  // точки + подписи
  hctx.fillStyle='#111'; hctx.font='10px Arial';
  const tickStep = Math.ceil(N/8);
  for (let i=0;i<N;i++){
    const x = leftPad + (W*(i/Math.max(1, N-1)));
    const y = topPad + H - (H*(values[i]/maxV));
    hctx.beginPath(); hctx.arc(x,y,2.5,0,Math.PI*2); hctx.fill();
    if (i%tickStep===0 || i===N-1){
      const d = new Date(data[i].ts);
      const label = d.toLocaleString(undefined,{month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit'});
      hctx.fillText(label, x-32, topPad+H+14);
    }
  }
}

// ======== Рисование основного графика ========
function mapValToY(val, minV, maxV){
  const h = canvas.height;
  const p = (val-minV)/(maxV-minV || 1);
  return (h-1) - p*(h-1);
}
function drawGraph(intensityValues, secondSeriesValues, isNormalized=false){
  ctx.clearRect(0,0,canvas.width, canvas.height);

  // Maxes
  let maxIntensity = 0;
  for (let v of intensityValues) if (v>maxIntensity) maxIntensity = v;
  if (!isFinite(maxIntensity) || maxIntensity<=0) maxIntensity = 1;

  let maxSecond = 0;
  for (let v of secondSeriesValues) if (v>maxSecond) maxSecond = v;
  if (!isFinite(maxSecond) || maxSecond<=0) maxSecond = 1;

  const maxIntensityForScale = maxIntensity * 1.05;
  const maxSecondForScale = maxSecond * 1.1;

  // grid
  ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--grid');
  ctx.lineWidth = 1;
  const steps=5;
  for (let i=0;i<=steps;i++){
    const y = mapValToY(maxIntensityForScale*i/steps, 0, maxIntensityForScale);
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width, y); ctx.stroke();
  }

  // axes
  ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--axes');
  ctx.lineWidth=1.5;
  ctx.beginPath();
  ctx.moveTo(0, canvas.height-1); ctx.lineTo(canvas.width, canvas.height-1);
  ctx.moveTo(0, 0); ctx.lineTo(0, canvas.height);
  ctx.stroke();

  // left labels
  ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--text');
  ctx.font='12px Arial'; ctx.textAlign='left';
  for (let i=0;i<=steps;i++){
    const val = maxIntensityForScale*i/steps;
    const y = mapValToY(val, 0, maxIntensityForScale);
    ctx.fillText(val.toExponential(2), 5, y-3);
  }
  ctx.save(); ctx.rotate(-Math.PI/2); ctx.fillText('Интенсивность (условн. ед.)', -canvas.height+10, 14); ctx.restore();

  // right labels
  ctx.textAlign='right';
  for (let i=0;i<=steps;i++){
    const val = maxSecondForScale*i/steps;
    const y = mapValToY(val, 0, maxSecondForScale);
    ctx.fillText(isNormalized? val.toFixed(2) : val.toExponential(2), canvas.width-5, y-3);
  }
  ctx.save(); ctx.rotate(Math.PI/2);
  ctx.fillText(isNormalized? 'Нормированная энергия (отн.)' : 'Энергия (Вт·с/м² — условно)', canvas.height/2 - 60, canvas.width - 10);
  ctx.restore();

  // series 1: intensity
  const N = intensityValues.length;
  const denom = Math.max(N-1, 1);
  ctx.beginPath();
  for (let i=0;i<N;i++){
    const x = (i/denom)*canvas.width;
    const y = mapValToY(intensityValues[i], 0, maxIntensityForScale);
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--blue');
  ctx.lineWidth=2; ctx.stroke();

  // series 2: energy or normalized
  const M = secondSeriesValues.length;
  ctx.beginPath();
  for (let i=0;i<M;i++){
    const x = (i/Math.max(M-1,1))*canvas.width;
    const y = mapValToY(secondSeriesValues[i], 0, maxSecondForScale);
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--green');
  ctx.lineWidth=2; ctx.stroke();

  // guide for last value
  if (secondSeriesValues.length>1){
    const last = secondSeriesValues[secondSeriesValues.length-1];
    const y = mapValToY(last, 0, maxSecondForScale);
    ctx.beginPath(); ctx.setLineDash([5,3]);
    ctx.moveTo((secondSeriesValues.length-1)/Math.max(1,(secondSeriesValues.length-1))*canvas.width, y);
    ctx.lineTo(canvas.width, y);
    ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--green-dark');
    ctx.lineWidth=1; ctx.stroke(); ctx.setLineDash([]);
  }
}

// ======== Доступ к микрофону (ТОЛЬКО по клику) ========
async function requestMicrophoneAccess(){
  try{
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
      setStatus('❌ getUserMedia не поддерживается в этом окружении.', 'error');
      return;
    }
    micStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation:true, noiseSuppression:true }, video:false });
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    source = audioCtx.createMediaStreamSource(micStream);
    source.connect(analyser);
    setStatus('✅ Доступ к микрофону получен.', 'ok');
  }catch(e){
    setStatus('❌ Доступ к микрофону отклонён или недоступен: '+ e.message, 'error');
  }
}

// ======== Запись/анализ ========
let intensityValues = [];
let integralValues = [];
function resetData(){
  intensityValues = [];
  integralValues = [];
  ctx.clearRect(0,0,canvas.width, canvas.height);
  setStatus('Данные сброшены.');
}

function rms(buf){
  let acc = 0;
  for (let i=0;i<buf.length;i++){ const v=buf[i]; acc += v*v; }
  return Math.sqrt(acc/(buf.length || 1));
}

function tick(){
  if (!recording) return;
  const mode = getMode();

  const buffer = new Float32Array(analyser.fftSize);
  analyser.getFloatTimeDomainData(buffer);
  // Интенсивность ~ RMS^2, условные единицы
  const r = rms(buffer);
  const intensity = r*r;
  const t = audioCtx.currentTime; // сек
  const dt = Math.max(0, t - lastT);
  lastT = t;

  // накапливаем интеграл
  const lastIntegral = integralValues.length ? integralValues[integralValues.length-1] : 0;
  const nextIntegral = lastIntegral + intensity * dt; // условные Вт·с/м²
  intensityValues.push(intensity);
  integralValues.push(nextIntegral);

  if (mode==='normalization'){
    drawGraph(intensityValues, integralValues, false);
  } else {
    const ref = getNormalizationReference();
    if (ref){
      const normalized = integralValues.map(v => v / ref); // может быть >1 и <1
      drawGraph(intensityValues, normalized, true);
    } else {
      drawGraph(intensityValues, integralValues, false); // fallback, если нет эталона
    }
  }

  rafId = requestAnimationFrame(tick);
}

function stopRecordingAndFinalize(){
  recording = false;
  if (rafId) { cancelAnimationFrame(rafId); rafId = null; }

  // Сохраняем асимптоту
  const lastIntegral = integralValues.length ? integralValues[integralValues.length-1] : 0;
  const mode = getMode();
  if (mode==='normalization'){
    addEnergyHistoryEntry(lastIntegral);
  } else {
    const ref = getNormalizationReference();
    if (ref){
      const lastNorm = lastIntegral / ref;
      addEnergyHistoryEntryMain(lastNorm);
    }
  }
  drawEnergyHistory();
  setStatus('✅ Анализ завершён.', 'ok');
}

// ======== Обработчики кнопок ========
btnRequestMic.addEventListener('click', async () => {
  await requestMicrophoneAccess();
});

btnStart.addEventListener('click', async () => {
  try{
    if (!micStream){
      await requestMicrophoneAccess();
      if (!micStream) return; // доступ не получен
    }
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') await audioCtx.resume();

    // подготовка данных
    intensityValues = [];
    integralValues = [];
    t0 = audioCtx.currentTime;
    lastT = t0;
    recording = true;
    setStatus('🟢 Запись запущена. Говорите/дышите в микрофон...', 'ok');
    tick();
  }catch(e){
    setStatus('❌ Не удалось начать запись: '+e.message, 'error');
  }
});

btnStop.addEventListener('click', () => {
  stopRecordingAndFinalize();
});

btnReset.addEventListener('click', () => {
  resetData();
});

btnStartNorm.addEventListener('click', () => {
  setMode('normalization');
  setStatus('🟡 Режим "Нормирование" активирован.', 'ok');
});

btnFinishNorm.addEventListener('click', () => {
  setMode('main');
  const ref = getNormalizationReference();
  if (!ref){
    setStatus('⚠️ Нет эталона нормирования — выполните хотя бы один сеанс в режиме нормирования.', 'warn');
  } else {
    setStatus('🟢 Нормирование завершено. Эталон установлен. Переход к основному режиму.', 'ok');
  }
});

// ======== Инициализация ========
window.addEventListener('load', () => {
  applyMode();
  drawEnergyHistory();
  setStatus('Готов. Сначала нажмите «Разрешить доступ к микрофону».', 'ok');
});
</script>
</body>
</html>
