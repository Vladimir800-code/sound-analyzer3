<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Acoustic Analyzer — index (with Share)</title>
<!-- build: AA build index_with_share_2025-09-12_r1 -->
<script>console.log("AA build index_with_share_2025-09-12_r1");</script>
<style>
  :root{
    --grid:#e9e9e9; --axes:#222; --text:#111;
    --blue:#2f6fed; --green:#1aab55;
    --warn:#b15d00; --ok:#0a7a2e; --error:#b00020;
  }
  body{font-family:Arial, sans-serif; margin:0; color:var(--text); background:#fff;}
  header{position:relative; padding:10px 12px; border-bottom:1px solid #ddd; background:#fafafa}
  h1{font-size:18px; margin:4px 0;}
  #langBox{position:absolute; right:12px; top:10px;}
  #langSelect{padding:6px 10px; border-radius:6px; border:1px solid #ccc;}
  main{padding:8px 0 18px;}
  .toolbar{display:flex; gap:8px; flex-wrap:wrap; margin:8px 12px; align-items:center;}
  .button{padding:8px 14px; border-radius:8px; border:1px solid #ccc; cursor:pointer; background:#f5f5f5}
  .button.primary{background:#2f6fed; border-color:#2f6fed; color:#fff}
  .button.alt{background:#fbe9e7; border-color:#f5ccbd; color:#5d2a00}
  #modeBadge{margin-left:auto; font-size:12px; padding:4px 8px; border-radius:999px; background:#eef; color:#223;}
  body[data-mode="normalization"] #modeBadge{background:#fff6d6; color:#6b4e00;}
  body[data-mode="main"] #modeBadge{background:#e6ffe7; color:#0a5c10;}
  .status{margin:8px 12px; font-size:14px;}
  .status.ok{color:var(--ok)} .status.warn{color:var(--warn)} .status.error{color:var(--error)}
  .card{border:1px solid #ddd; border-radius:10px; padding:10px 12px; background:#fff; margin:8px 12px;}
  .hint{font-size:12px; color:#555; margin:0 12px 12px;}
  canvas{border:1px solid #ddd; border-radius:6px; margin:8px 12px;}
  .signal-info{margin:8px 12px; padding:8px; background:#f9f9f9; border-radius:6px; font-family:monospace; font-size:13px;}
  .small{font-size:12px; color:#666; margin: 0 12px;}
  .modal-backdrop{ position: fixed; inset: 0; background: rgba(0,0,0,0.35); display: none; z-index: 1200; }
  .modal-card{ position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
               background: #fff; border-radius: 12px; border: 1px solid #ddd; width: min(560px, 92vw);
               box-shadow: 0 12px 40px rgba(0,0,0,0.25); }
  .modal-header{ padding: 12px 16px; border-bottom: 1px solid #eee; display:flex; align-items:center; gap:8px; }
  .modal-title{ font-weight: 700; font-size:16px; }
  .modal-body{ padding: 14px 16px 18px; }
  .modal-actions{ padding: 10px 16px; border-top: 1px solid #eee; display:flex; justify-content:flex-end; gap:8px; }
  .threshold-info{margin:4px 0; padding:6px; background:#f0f8ff; border-radius:4px; font-family:monospace; font-size:12px; color:#0066cc;}
</style>
</head>
<body>
<header>
  <h1 id="titleText">Акустический анализ — Этап 1: «Нормирование» → Этап 2: «Основной анализ»</h1>
  <div id="langBox">
    <select id="langSelect">
      <option value="ru">Русский</option>
      <option value="en">English</option>
      <option value="he">עברית</option>
    </select>
  </div>
</header>

<main>
  <div class="toolbar" id="normToolbar">
    <button id="btnStartNorm" class="button">Начать нормирование</button>
    <button id="btnFinishNorm" class="button primary">Закончить нормирование</button>
    <span id="modeBadge">Режим: —</span>
  </div>

  <div class="toolbar">
    <button id="btnRequestMic" class="button alt">Разрешить доступ к микрофону</button>
    <button id="btnStart" class="button">Начать запись</button>
    <button id="btnStop" class="button">Остановить</button>
    <button id="btnReset" class="button">Сброс</button>
    <button id="btnTech" class="button">Технические настройки</button>
    <button id="btnShare" class="button">Поделиться</button>
  </div>

  <div class="status" id="status">Готов.</div>
  <div class="small" id="axisNote">Оси: авто‑масштаб с автообрезкой по 95‑му перцентилю</div>
  <canvas id="mainGraph" width="980" height="340"></canvas>
  <div class="signal-info" id="signalInfo">Начало: — с, Конец: — с, Длительность: — с</div>

  <section id="historySection" class="card">
    <h3 style="margin:0 0 6px 0;">История результатов текущего режима</h3>
    <canvas id="historyGraph" width="980" height="240"></canvas>
    <div class="hint">Нормирование — абсолютные асимптоты энергии; Основной — нормированные. Ось X: время (локальное).</div>
    <div class="toolbar" style="justify-content:flex-end; margin-top:4px;">
      <button id="btnResetLast" class="button">Сбросить последнее</button>
    </div>
  </section>
</main>

<!-- Technical settings modal (always English) -->
<div id="techModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="techTitle">
  <div class="modal-card" onclick="event.stopPropagation();">
    <div class="modal-header">
      <span id="techTitle" class="modal-title">Technical settings</span>
    </div>
    <div class="modal-body">
      <div class="threshold-info" id="thresholdInfo">Current threshold: —</div>
      <div style="margin-top:10px; font-size:14px;">
        <label for="thrSlider" style="display:block; margin-bottom:6px; font-weight:600;">Relative threshold, %</label>
        <div style="display:flex; align-items:center; gap:10px;">
          <input id="thrSlider" type="range" min="0" max="10" step="0.5" value="5" style="flex:1;">
          <span id="thrValue" style="min-width:56px; text-align:right;">5.0%</span>
        </div>
      </div>
      <div style="margin-top:14px; font-size:14px;">
        <label for="stabSlider" style="display:block; margin-bottom:6px; font-weight:600;">Stability criterion, %</label>
        <div style="display:flex; align-items:center; gap:10px;">
          <input id="stabSlider" type="range" min="0" max="5" step="0.25" value="1" style="flex:1;">
          <span id="stabValue" style="min-width:56px; text-align:right;">1.00%</span>
        </div>
      </div>
    </div>
    <div class="modal-actions">
      <button id="btnCloseTech" class="button">Close</button>
    </div>
  </div>
</div>

<script>
"use strict";
/* I18N */
const LANG_KEY='ui_lang_v1';
function currLang(){ return localStorage.getItem(LANG_KEY)||'ru'; }
const translations={
  ru:{title:"Акустический анализ — Этап 1: «Нормирование» → Этап 2: «Основной анализ»",startNorm:"Начать нормирование",finishNorm:"Закончить нормирование",requestMic:"Разрешить доступ к микрофону",startRec:"Начать запись",stopRec:"Остановить",reset:"Сброс",resetLast:"Сбросить последнее",historyTitle:"История результатов текущего режима",historyHint:"Нормирование — абсолютные асимптоты энергии; Основной — нормированные. Ось X: время (локальное).",ready:"Готов.",modeBadgeNorm:"Режим: Нормирование",modeBadgeMain:"Режим: Основной анализ",yLeft:"Интенсивность (усл. ед.)",yRightNorm:"Нормированная энергия (отн.)",yRightRaw:"Энергия (отн.)",histYNorm:"Нормированная асимптота",histYAbs:"Интегральная энергия",histX:"Время",statusMicOk:"✅ Доступ к микрофону получен.",statusMicErr:"❌ Нет доступа к микрофону: ",statusRec:"🟢 Запись…",statusReset:"Сброс данных.",statusNormOn:"🟡 Режим нормирования.",statusMainDone:"✅ Анализ завершён.",signalInfo:"Начало: — с, Конец: — с, Длительность: — с",startLabel:"Начало",endLabel:"Конец",durationLabel:"Длительность",cutLabel:"Точка отсечения",secUnit:"с"},
  en:{title:"Acoustic Analysis — Stage 1: Normalization → Stage 2: Main Analysis",startNorm:"Start normalization",finishNorm:"Finish normalization",requestMic:"Allow microphone access",startRec:"Start recording",stopRec:"Stop",reset:"Reset",resetLast:"Reset last",historyTitle:"History of current mode results",historyHint:"Normalization — absolute energy; Main — normalized. X axis: local time.",ready:"Ready.",modeBadgeNorm:"Mode: Normalization",modeBadgeMain:"Mode: Main analysis",yLeft:"Intensity (arb.)",yRightNorm:"Normalized energy (rel.)",yRightRaw:"Energy (rel.)",histYNorm:"Normalized asymptote",histYAbs:"Integral energy",histX:"Time",statusMicOk:"✅ Microphone access granted.",statusMicErr:"❌ Microphone access denied: ",statusRec:"🟢 Recording…",statusReset:"Data reset.",statusNormOn:"🟡 Normalization mode.",statusMainDone:"✅ Analysis finished.",signalInfo:"Start: — s, End: — s, Duration: — s",startLabel:"Start",endLabel:"End",durationLabel:"Duration",cutLabel:"Cutoff point",secUnit:"s"},
  he:{title:"‏ניתוח אקוסטי — שלב 1: נרמול → שלב 2: ניתוח עיקרי",startNorm:"התחל נרמול",finishNorm:"סיים נרמול",requestMic:"אפשר גישה למיקרופון",startRec:"התחל הקלטה",stopRec:"עצור",reset:"איפוס",resetLast:"איפוס אחרון",historyTitle:"היסטוריית תוצאות המצב הנוכחי",historyHint:"נרמול — אנרגיה מוחלטת; עיקרי — מנורמלת. ציר X: זמן מקומי.",ready:"מוכן.",modeBadgeNorm:"מצב: נרמול",modeBadgeMain:"מצב: ניתוח עיקרי",yLeft:"עוצמה",yRightNorm:"אנרגיה מנורמלת",yRightRaw:"אנרגיה",histYNorm:"אסימפטוטה מנורמלת",histYAbs:"אנרגיה אינטגרלית",histX:"זמן",statusMicOk:"✅ הוענקה גישה למיקרופון.",statusMicErr:"❌ אין גישה למיקרופון: ",statusRec:"🟢 הקלטה…",statusReset:"איפוס נתונים.",statusNormOn:"🟡 מצב נרמול.",statusMainDone:"✅ הניתוח הושלם.",signalInfo:"התחלה: — ש, סוף: — ש, משך: — ש",startLabel:"התחלה",endLabel:"סוף",durationLabel:"משך",cutLabel:"נקודת חיתוך",secUnit:"ש"}
};
function tr(key){ const lang=(localStorage.getItem(LANG_KEY)||'ru'); const pack=translations[lang]||translations.ru; return pack[key]??key; }
function setStatus(msg, level='ok'){ const el=document.getElementById('status'); el.className='status '+(level||'ok'); el.textContent=msg; }

/* Helpers */
function niceNum(range, round){
  const exp = Math.floor(Math.log10(range||1));
  const f = (range / Math.pow(10, exp)) || 1;
  let nf;
  if (round){
    if (f < 1.5) nf = 1;
    else if (f < 3) nf = 2;
    else if (f < 7) nf = 5;
    else nf = 10;
  }else{
    if (f <= 1) nf = 1;
    else if (f <= 2) nf = 2;
    else if (f <= 5) nf = 5;
    else nf = 10;
  }
  return nf * Math.pow(10, exp);
}
function niceAxis(minV, maxV, maxTicks=6){
  if (!isFinite(minV) || !isFinite(maxV)) { minV=0; maxV=1; }
  if (minV === maxV) { maxV = minV + 1; }
  const range = niceNum(maxV - minV, false);
  const step  = niceNum(range / (maxTicks - 1), true);
  const graphMin = Math.floor(minV / step) * step;
  const graphMax = Math.ceil (maxV / step) * step;
  const ticks = [];
  for (let v=graphMin; v<=graphMax + 0.5*step; v+=step){ ticks.push(v); }
  return {min:graphMin, max:graphMax, step, ticks};
}
function percentile(arr, p){
  const a = arr.slice().filter(v=>isFinite(v)).sort((x,y)=>x-y);
  if (!a.length) return 0;
  const idx = (p/100)*(a.length-1);
  const lo = Math.floor(idx), hi = Math.ceil(idx);
  if (lo===hi) return a[lo];
  const w = idx - lo;
  return a[lo]*(1-w) + a[hi]*w;
}
function fmtVal(v){
  const av = Math.abs(v);
  if (av>0 && (av<1e-3 || av>=1e5)) return v.toExponential(2);
  const s = v.toFixed( (av<1?3:(av<10?2:(av<100?1:0))) );
  return s.replace('.', ',');
}

/* State */
let audioCtx=null, analyser=null, micStream=null, source=null;
let rafId=null, recording=false, t0=0, lastT=0;
let intensityValues=[], integralValues=[], sampleTimes=[];
let signalStartTime=null, signalEndTime=null, isSignalActive=false;
let lastIntegralValue=0, stableCount=0, maxIntensity=0, currentThreshold=0;

const MODE_KEY='analysisModeV1';
const ENERGY_HISTORY_KEY='energyHistoryV1';
const ENERGY_HISTORY_MAIN_KEY='energyHistoryMainV1';

/* Settings */
const THRESHOLD_PCT_KEY = 'thr_pct_v1';
const STABILITY_PCT_KEY = 'stability_pct_v1';
function getThresholdPct(){ let v=parseFloat(localStorage.getItem(THRESHOLD_PCT_KEY)); return (v>=0&&v<=10)?v:5; }
function setThresholdPct(v){ v=Math.max(0,Math.min(10,Number(v)||0)); localStorage.setItem(THRESHOLD_PCT_KEY,String(v)); }
function getRelativeThresholdFraction(){ return getThresholdPct()/100; }
function getStabilityPct(){ let v=parseFloat(localStorage.getItem(STABILITY_PCT_KEY)); return (v>=0&&v<=5)?v:1; }
function setStabilityPct(v){ v=Math.max(0,Math.min(5,Number(v)||0)); localStorage.setItem(STABILITY_PCT_KEY,String(v)); }
function getStabilityCriterion(){ return getStabilityPct()/100; }
const ABSOLUTE_FLOOR=0.001, STABLE_SAMPLES_REQUIRED=10, AUTO_STOP_AFTER_END=3.0, MAX_RECORDING_TIME=30.0;

function getMode(){ const v=localStorage.getItem(MODE_KEY); return (v==='main'||v==='normalization')?v:'normalization'; }
function setMode(v){ localStorage.setItem(MODE_KEY,v); applyMode(); }
function applyMode(){
  const mode=getMode();
  document.body.setAttribute('data-mode',mode);
  document.getElementById('modeBadge').textContent=(mode==='normalization')?tr('modeBadgeNorm'):tr('modeBadgeMain');
  drawEnergyHistory();
}

/* I18N apply */
function applyTranslations(lang){
  localStorage.setItem(LANG_KEY, lang);
  document.getElementById('titleText').textContent = tr('title');
  document.getElementById('btnStartNorm').textContent = tr('startNorm');
  document.getElementById('btnFinishNorm').textContent = tr('finishNorm');
  document.getElementById('btnRequestMic').textContent = tr('requestMic');
  document.getElementById('btnStart').textContent = tr('startRec');
  document.getElementById('btnStop').textContent = tr('stopRec');
  document.getElementById('btnReset').textContent = tr('reset');
  document.querySelector('#historySection h3').textContent = tr('historyTitle');
  document.querySelector('#historySection .hint').textContent = tr('historyHint');
  document.getElementById('axisNote').textContent = "Оси: авто‑масштаб с автообрезкой по 95‑му перцентилю";
  applyMode();
  updateSignalInfo();
  setStatus(tr('ready'),'ok');
}

/* History */
function loadEnergyHistory(){ try{const r=localStorage.getItem(ENERGY_HISTORY_KEY); return r?JSON.parse(r):[];}catch(e){return [];} }
function saveEnergyHistory(a){ try{localStorage.setItem(ENERGY_HISTORY_KEY,JSON.stringify(a));}catch(e){} }
function addEnergyHistoryEntry(e){ const d=new Date(); const h=loadEnergyHistory(); h.push({ts:d.toISOString(),energy:Number(e)||0}); saveEnergyHistory(h); }
function loadEnergyHistoryMain(){ try{const r=localStorage.getItem(ENERGY_HISTORY_MAIN_KEY); return r?JSON.parse(r):[];}catch(e){return [];} }
function saveEnergyHistoryMain(a){ try{localStorage.setItem(ENERGY_HISTORY_MAIN_KEY,JSON.stringify(a));}catch(e){} }
function addEnergyHistoryEntryMain(n){ const d=new Date(); const h=loadEnergyHistoryMain(); h.push({ts:d.toISOString(),norm:Number(n)||0}); saveEnergyHistoryMain(h); }
function getNormalizationReference(){ const h=loadEnergyHistory(); if(!h.length) return null; let m=-Infinity; for(const x of h){const v=Number(x.energy)||0; if(v>m)m=v;} return (isFinite(m)&&m>0)?m:null; }

/* Axes with auto‑clip */
function drawAxes(ctx, W, H, leftPad, bottomPad, yTicks, yMin, yMax, xTicks, xFormatter, yFormatter){
  ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--grid'); ctx.lineWidth=1;
  yTicks.forEach(v=>{ const y = (H - bottomPad) - ( (v - yMin) / (yMax - yMin || 1) ) * (H - bottomPad - 10); ctx.beginPath(); ctx.moveTo(leftPad, y); ctx.lineTo(W-10, y); ctx.stroke(); });
  ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--axes'); ctx.beginPath();
  ctx.moveTo(leftPad, 10); ctx.lineTo(leftPad, H - bottomPad); ctx.lineTo(W - 10, H - bottomPad); ctx.stroke();
  ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--text'); ctx.font='11px Arial'; ctx.textAlign='right';
  yTicks.forEach(v=>{ const y = (H - bottomPad) - ( (v - yMin) / (yMax - yMin || 1) ) * (H - bottomPad - 10); ctx.fillText(yFormatter(v), leftPad - 6, y - 2); });
  ctx.textAlign='center';
  xTicks.forEach((tick)=>{
    const x = leftPad + (tick.pos * (W - leftPad - 10));
    ctx.beginPath(); ctx.moveTo(x, H - bottomPad); ctx.lineTo(x, H - bottomPad + 4); ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--axes'); ctx.stroke();
    ctx.fillText(xFormatter(tick.label), x, H - bottomPad + 16);
  });
}

/* Live graph */
const canvas=document.getElementById('mainGraph'), ctx=canvas.getContext('2d');
const historyCanvas=document.getElementById('historyGraph'), hctx=historyCanvas.getContext('2d');

function drawGraph(intensityValues, secondSeries, isNorm=false){
  const W=canvas.width, H=canvas.height, leftPad=60, bottomPad=24;
  ctx.clearRect(0,0,W,H);
  const yAll=[...intensityValues,...secondSeries].filter(v=>isFinite(v) && v>=0);
  const clipMax = percentile(yAll, 95);
  const yMin=0, yMax=Math.max(clipMax, 1e-6);
  const yAxis=niceAxis(yMin, yMax, 6);
  const T = (sampleTimes.length?sampleTimes[sampleTimes.length-1]:0) || 0;
  const xAxis = niceAxis(0, Math.max(T,1), 6);
  const xTicks = xAxis.ticks.map(v=>({pos: (v - xAxis.min)/(xAxis.max - xAxis.min || 1), label: v}));
  drawAxes(ctx, W, H, leftPad, bottomPad, yAxis.ticks, yAxis.min, yAxis.max, xTicks, v=>String(v), fmtVal);
  function X(i){ const t = sampleTimes[i]||0; return leftPad + ((t - xAxis.min)/(xAxis.max - xAxis.min || 1))*(W - leftPad - 10); }
  function Y(val){ return (H - bottomPad) - ((val - yAxis.min)/(yAxis.max - yAxis.min || 1))*(H - bottomPad - 10); }
  ctx.beginPath(); for(let i=0;i<intensityValues.length;i++){ const x=X(i), y=Y(intensityValues[i]||0); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--blue'); ctx.lineWidth=2; ctx.stroke();
  ctx.beginPath(); for(let i=0;i<secondSeries.length;i++){ const x=X(i), y=Y(secondSeries[i]||0); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--green'); ctx.lineWidth=2; ctx.stroke();
}

/* History graph (time on X, auto‑clip) */
function drawEnergyHistory(){
  const isMain=(getMode()==='main');
  const data=isMain?loadEnergyHistoryMain():loadEnergyHistory();
  const W=historyCanvas.width, H=historyCanvas.height, leftPad=60, bottomPad=26;
  hctx.clearRect(0,0,W,H);
  if(!data.length){
    hctx.fillStyle='#555'; hctx.font='14px Arial'; hctx.fillText(isMain?'История основного режима пуста.':'История нормирования пуста.',20,30);
    return;
  }
  const vals=data.map(d=>isMain?(+d.norm||0):(+d.energy||0)).filter(v=>isFinite(v)&&v>=0);
  const yMax = Math.max(percentile(vals,95), 1e-6);
  const yAxis=niceAxis(0, yMax, 6);
  const ts = data.map(d=>new Date(d.ts).getTime());
  const tMin=Math.min(...ts), tMax=Math.max(...ts), tRange=Math.max(1, tMax - tMin);
  const ticksCount = 6, xTicks=[];
  for(let i=0;i<ticksCount;i++){ const f = (ticksCount===1)?0:(i/(ticksCount-1)); const tt = tMin + f*tRange; xTicks.push({pos:f, label: tt}); }
  const xFormatter=(tms)=> new Date(tms).toLocaleString(undefined,{month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit'});
  drawAxes(hctx, W, H, leftPad, bottomPad, yAxis.ticks, yAxis.min, yAxis.max, xTicks, xFormatter, fmtVal);
  function X(idx){ const f = (ts[idx]-tMin)/tRange; return leftPad + f*(W - leftPad - 10); }
  function Y(val){ return (H - bottomPad) - ((val - yAxis.min)/(yAxis.max - yAxis.min || 1))*(H - bottomPad - 10); }
  hctx.beginPath(); for(let i=0;i<vals.length;i++){ const x=X(i), y=Y(vals[i]); if(i===0) hctx.moveTo(x,y); else hctx.lineTo(x,y); } hctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--green'); hctx.lineWidth=2; hctx.stroke();
}

/* Info */
function composeSignalInfoText(){
  const sec=tr('secUnit'); const startLbl=tr('startLabel'); const endLbl=tr('endLabel'); const durLbl=tr('durationLabel');
  if (signalStartTime!==null && signalEndTime!==null){
    const d=signalEndTime-signalStartTime; return `${startLbl}: ${signalStartTime.toFixed(2)} ${sec}, ${endLbl}: ${signalEndTime.toFixed(2)} ${sec}, ${durLbl}: ${d.toFixed(2)} ${sec}`;
  } else if (signalStartTime!==null){
    return `${startLbl}: ${signalStartTime.toFixed(2)} ${sec}, ${endLbl}: — ${sec}, ${durLbl}: — ${sec}`;
  } else return tr('signalInfo');
}
function updateSignalInfo(){ const el=document.getElementById('signalInfo'); el.textContent=composeSignalInfoText(); }

/* Mic */
async function requestMicrophoneAccess(){
  try{
    micStream=await navigator.mediaDevices.getUserMedia({audio:true});
    audioCtx=new (window.AudioContext||window.webkitAudioContext)();
    analyser=audioCtx.createAnalyser(); analyser.fftSize=2048;
    source=audioCtx.createMediaStreamSource(micStream); source.connect(analyser);
    setStatus(tr('statusMicOk'),'ok');
  }catch(e){ setStatus(tr('statusMicErr')+(e&&e.message?e.message:''),'error'); }
}

/* Recording tick */
function rms(b){let a=0;for(let v of b)a+=v*v;return Math.sqrt(a/(b.length||1));}
function detectSignal(intensity, currentIntegral, currentTime){
  const timeFromStart=currentTime - t0;
  maxIntensity=Math.max(maxIntensity,intensity);
  const relThr=Math.max(maxIntensity*getRelativeThresholdFraction(), ABSOLUTE_FLOOR);
  currentThreshold=relThr;
  if(!isSignalActive && intensity>relThr){
    isSignalActive=true; signalStartTime=timeFromStart; lastIntegralValue=currentIntegral; stableCount=0; return 'start';
  }
  if(isSignalActive && currentIntegral>0){
    const relativeChange=Math.abs((currentIntegral-lastIntegralValue)/currentIntegral);
    if(relativeChange<=getStabilityCriterion()){
      stableCount++; if(stableCount>=STABLE_SAMPLES_REQUIRED && signalEndTime===null){ isSignalActive=false; signalEndTime=timeFromStart; stableCount=0; return 'end'; }
    } else { stableCount=0; lastIntegralValue=currentIntegral; }
  }
  return null;
}
function checkAutoStop(t){
  const elapsed=t - t0;
  if(elapsed>=MAX_RECORDING_TIME){ stopRecordingAndFinalize(); setStatus('⏱️ 30 сек. лимит','warn'); return true; }
  if(signalEndTime!==null){
    if((elapsed - signalEndTime)>=AUTO_STOP_AFTER_END){ stopRecordingAndFinalize(); setStatus('⏱️ Автостоп','ok'); return true; }
  }
  return false;
}
function tick(){
  if(!recording) return;
  const buffer=new Float32Array(analyser.fftSize); analyser.getFloatTimeDomainData(buffer);
  const r=rms(buffer), intensity=r*r;
  const t=audioCtx.currentTime, dt=Math.max(0,t-lastT); lastT=t;
  const last=(integralValues.length?integralValues[integralValues.length-1]:0);
  const next=last+intensity*dt;
  intensityValues.push(intensity); integralValues.push(next); sampleTimes.push(t - t0);
  if(checkAutoStop(t)) return;
  const ev=detectSignal(intensity,next,t);
  if(ev==='start') setStatus('🔊', 'ok');
  if(ev==='end') setStatus('🔇', 'ok');
  updateSignalInfo();
  const mode=getMode();
  if(mode==='normalization'){ drawGraph(intensityValues, integralValues, false); }
  else{
    const ref=getNormalizationReference();
    const lastInt = integralValues[integralValues.length-1] || 1;
    const norm = ref ? integralValues.map(v=>v/(ref||1)) : integralValues.map(v=>v/(lastInt||1));
    drawGraph(intensityValues, norm, true);
  }
  rafId=requestAnimationFrame(tick);
}
function stopRecordingAndFinalize(){
  recording=false; if(rafId) cancelAnimationFrame(rafId);
  if(signalStartTime!==null && signalEndTime===null){ signalEndTime=lastT - t0; }
  const mode=getMode();
  const last=integralValues.length?integralValues[integralValues.length-1]:0;
  if(mode==='normalization'){ addEnergyHistoryEntry(last); setStatus(tr('statusNormOn'),'warn'); }
  else{
    const ref=getNormalizationReference();
    const norm = ref ? (last/(ref||1)) : 1;
    addEnergyHistoryEntryMain(norm);
    setStatus(tr('statusMainDone'),'ok');
  }
  drawEnergyHistory();
}
function resetRecording(){
  recording=false; if(rafId) cancelAnimationFrame(rafId);
  intensityValues=[]; integralValues=[]; sampleTimes=[];
  signalStartTime=null; signalEndTime=null; isSignalActive=false;
  lastIntegralValue=0; stableCount=0; maxIntensity=0; currentThreshold=0; t0=0; lastT=0;
  ctx.clearRect(0,0,canvas.width,canvas.height); updateSignalInfo();
  setStatus(tr('statusReset'),'ok');
}

/* Robust SHARE (HTML-only) — tolerant, embeds data, multiple fallbacks */
function collectHistoriesForExport(){
  let norm = []; try{ norm = loadEnergyHistory() || []; }catch(_){ norm = []; }
  let main = []; try{ main = loadEnergyHistoryMain() || []; }catch(_){ main = []; }
  return {normHist:Array.isArray(norm)?norm:[], mainHist:Array.isArray(main)?main:[]};
}
function buildReportHTML(normHist, mainHist){
  const norm = JSON.stringify(normHist).replace(/</g,'\\u003C');
  const main = JSON.stringify(mainHist).replace(/</g,'\\u003C');
  const parts = [];
  parts.push('<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><title>Acoustic Share Report</title>');
  parts.push('<meta name="viewport" content="width=device-width, initial-scale=1">');
  parts.push('<style>body{font-family:Arial,sans-serif;margin:20px;}h1{font-size:20px;margin:0 0 6px 0;}h2{font-size:16px;margin:14px 0 6px 0;}canvas{border:1px solid #ddd;border-radius:6px;width:100%;height:260px;}table{border-collapse:collapse;width:100%;font-size:12px;}th,td{border:1px solid #ccc;padding:6px 8px;}th{background:#f5f5f5;}.grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;align-items:start;}.legend{display:flex;gap:14px;align-items:center;margin:6px 0 2px 0;font-size:12px;color:#333}.chip{width:12px;height:12px;border-radius:2px;display:inline-block;border:1px solid #999}.c-energy{background:#cfe8ff;border-color:#6aa0ff}.c-norm{background:#d7f5e3;border-color:#42a362}.c-cut{background:#ffd7e8;border-color:#ff66a3}.bg-red{background:rgba(255,0,0,0.08)}.bg-yellow{background:rgba(255,215,0,0.10)}.bg-green{background:rgba(0,128,0,0.10)}.card{border:1px solid #ddd;border-radius:10px;padding:12px;margin:10px 0;}.note{margin:8px 0 0 2px;color:#666;font-size:12px;}</style>');
  parts.push('</head><body>');
  parts.push('<h1>Акустический спироанализатор — отчёт</h1>');
  parts.push('<div>Дата формирования: ' + new Date().toLocaleString() + '</div>');
  parts.push('<div class="card"><h2>История нормирования</h2>');
  parts.push('<div class="legend"><span class="chip c-energy"></span> Интегральная энергия</div>');
  parts.push('<div class="grid"><canvas id="cnNorm" width="800" height="260"></canvas>');
  parts.push('<div><table><thead><tr><th>#</th><th>Время</th><th>Energy (sci)</th></tr></thead><tbody id="tbNorm"></tbody></table>');
  parts.push('<div class="note" id="noteNorm"></div></div></div></div>');
  parts.push('<div class="card"><h2>История основного режима</h2>');
  parts.push('<div class="legend"><span class="chip c-norm"></span> Нормированная асимптота <span class="chip c-cut"></span> Точка отсечения</div>');
  parts.push('<div class="grid"><canvas id="cnMain" width="800" height="260"></canvas>');
  parts.push('<div><table><thead><tr><th>#</th><th>Время</th><th>Norm</th><th>Cut, %</th></tr></thead><tbody id="tbMain"></tbody></table>');
  parts.push('<div class="note" id="noteMain"></div></div></div></div>');
  const closeScript = '<' + '/script>';
  parts.push('<script>');
  parts.push('const dataNorm = ' + norm + '; const dataMain = ' + main + ';');
  parts.push(`
function percentile(a,p){a=a.slice().filter(v=>isFinite(v)).sort((x,y)=>x-y);if(!a.length)return 0;const i=(p/100)*(a.length-1);const lo=Math.floor(i),hi=Math.ceil(i);if(lo===hi)return a[lo];const w=i-lo;return a[lo]*(1-w)+a[hi]*w;}
function niceNum(r,round){const e=Math.floor(Math.log10(r||1)),f=(r/Math.pow(10,e))||1;let nf;if(round){if(f<1.5)nf=1;else if(f<3)nf=2;else if(f<7)nf=5;else nf=10;}else{if(f<=1)nf=1;else if(f<=2)nf=2;else if(f<=5)nf=5;else nf=10;}return nf*Math.pow(10,e);}
function niceAxis(a,b,n){if(a===b){b=a+1;}const rg=niceNum(b-a,false),st=niceNum(rg/(n-1),true),g0=Math.floor(a/st)*st,g1=Math.ceil(b/st)*st;const t=[];for(let v=g0;v<=g1+0.5*st;v+=st)t.push(v);return{min:g0,max:g1,step:st,ticks:t};}
function drawHistory(canvasId, rows, isMain){
  const c = document.getElementById(canvasId), x = c.getContext('2d');
  const left=50, right=20, top=12, bottom=28, W=c.width-left-right, H=c.height-top-bottom;
  x.clearRect(0,0,c.width,c.height);
  if(!rows || !rows.length){ x.fillStyle='#555'; x.font='14px Arial'; x.fillText('Нет данных',20,30); return; }
  const vals = rows.map(r=> isMain ? (+r.norm||0) : (+r.energy||0) );
  const maxCandidate = isMain ? Math.max.apply(null, vals.concat([1])) : Math.max(percentile(vals,95), 1e-12);
  const ax = niceAxis(0, maxCandidate, 6);
  x.strokeStyle='#e9e9e9'; x.lineWidth=1;
  ax.ticks.forEach(v=>{const y=top+H-(H*((v-ax.min)/(ax.max-ax.min||1)));x.beginPath();x.moveTo(left,y);x.lineTo(left+W,y);x.stroke();});
  x.strokeStyle='#000'; x.beginPath(); x.moveTo(left,top); x.lineTo(left,top+H); x.lineTo(left+W,top+H); x.stroke();
  x.fillStyle='#111'; x.font='11px Arial';
  ax.ticks.forEach(v=>{ const y=top+H-(H*((v-ax.min)/(ax.max-ax.min||1))); const lab=isMain?v.toFixed(2):(v===0?'0':Number(v).toExponential(2)); x.fillText(lab,6,y-2); });
  if (isMain){
    const yFromVal=(val)=> top+H-(H*((val-ax.min)/(ax.max-ax.min||1)));
    const y0=yFromVal(0), y05=yFromVal(0.5), y08=yFromVal(0.8), y10=yFromVal(1.0);
    x.fillStyle='rgba(255,0,0,0.08)';   x.fillRect(left, Math.min(y0,y05), W, Math.abs(y05-y0));
    x.fillStyle='rgba(255,215,0,0.10)'; x.fillRect(left, Math.min(y05,y08), W, Math.abs(y08-y05));
    x.fillStyle='rgba(0,128,0,0.10)';   x.fillRect(left, Math.min(y08,y10), W, Math.abs(y10-y08));
  }
  x.fillStyle='#111'; x.font='10px Arial'; const N=rows.length, step=Math.ceil(N/8);
  for(let i=0;i<N;i++){ const xv=left+(W*(i/Math.max(1,N-1))); if(i%step===0||i===N-1){ const d=new Date(rows[i].ts); const lab=d.toLocaleString(undefined,{month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit'}); x.fillText(lab, xv-32, top+H+14); } }
  x.beginPath();
  for(let i=0;i<N;i++){ const xv=left+(W*(i/Math.max(1,N-1))); const yv=top+H-(H*((vals[i]-ax.min)/(ax.max-ax.min||1))); if(i===0) x.moveTo(xv,yv); else x.lineTo(xv,yv); }
  x.strokeStyle=isMain?'#1aab55':'#2f6fed'; x.lineWidth=2; x.stroke();
  if(isMain){
    x.beginPath(); let started=false;
    for(let i=0;i<N;i++){ const rec=rows[i]||{}; if(typeof rec.cut==='number'){ const xv=left+(W*(i/Math.max(1,N-1))); const yv=top+H-(H*(( (rec.cut/100)-ax.min)/(ax.max-ax.min||1))); if(!started){ x.moveTo(xv,yv); started=true; } else x.lineTo(xv,yv); } }
    if(started){ x.strokeStyle='#ff0066'; x.lineWidth=1.5; x.stroke(); }
    for(let i=0;i<N;i++){ const rec=rows[i]||{}; if(typeof rec.cut==='number'){ const xv=left+(W*(i/Math.max(1,N-1))); const yv=top+H-(H*(( (rec.cut/100)-ax.min)/(ax.max-ax.min||1))); x.beginPath(); x.arc(xv,yv,3.5,0,Math.PI*2); x.fillStyle='#ff0066'; x.fill(); } }
  }
}
function fillTableNorm(tid, rows){
  const tb=document.getElementById(tid); tb.innerHTML='';
  if(!rows.length){ document.getElementById('noteNorm').textContent='Нет данных нормирования.'; return; }
  rows.forEach((r,i)=>{ const tr=document.createElement('tr'); const ts = new Date(r.ts).toLocaleString(); const en = (r.energy!=null)?((Number(r.energy)===0)?'0':Number(r.energy).toExponential(3).replace('e','×10^')):''; [i+1, ts, en].forEach(val=>{ const td=document.createElement('td'); td.textContent=String(val); tr.appendChild(td); }); tb.appendChild(tr); });
}
function fillTableMain(tid, rows){
  const tb=document.getElementById(tid); tb.innerHTML='';
  if(!rows.length){ document.getElementById('noteMain').textContent='Нет данных основного режима.'; return; }
  rows.forEach((r,i)=>{ const tr=document.createElement('tr'); const cells=[i+1, new Date(r.ts).toLocaleString(), (r.norm!=null)?Number(r.norm).toFixed(3):'', (r.cut!=null)?(Number(r.cut).toFixed(1)):'']; cells.forEach(val=>{ const td=document.createElement('td'); td.textContent=String(val); tr.appendChild(td); }); tb.appendChild(tr); });
}
(function(){
  const normRows = Array.isArray(dataNorm)?dataNorm:[];
  const mainRows = Array.isArray(dataMain)?dataMain:[];
  drawHistory('cnNorm', normRows, false);
  fillTableNorm('tbNorm', normRows);
  drawHistory('cnMain', mainRows, true);
  fillTableMain('tbMain', mainRows);
})();`);
  parts.push(closeScript + '>');
  parts.push('</body></html>');
  return parts.join("");
}
function tryDownload(filename, html){
  try{
    const blob = new Blob([html], {type:'text/html;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.rel = 'noopener';
    a.target = '_blank';
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
    return true;
  }catch(err){ console.warn('Blob download blocked:', err); return false; }
}
function tryOpenNewTab(html){
  const w = window.open('', '_blank');
  if(!w){ return false; }
  try{
    w.document.open('text/html', 'replace');
    w.document.write(html);
    w.document.close();
    return true;
  }catch(err){
    try{ w.close(); }catch(_){}
    console.warn('Open new tab blocked:', err);
    return false;
  }
}
function exportHTMLReport(){
  const {normHist, mainHist} = collectHistoriesForExport();
  const html = buildReportHTML(normHist, mainHist);
  const stamp = new Date().toISOString().replace(/[:.]/g,'-').slice(0,19);
  const filename = 'acoustic_share_'+stamp+'.html';
  if (tryDownload(filename, html)) return;
  if (tryOpenNewTab(html)) return;
  const ta=document.createElement('textarea'); ta.style.cssText='position:fixed;inset:10px;z-index:99999'; ta.value=html; document.body.appendChild(ta);
  alert('Сайт блокирует загрузку. Выделите и скопируйте HTML, сохраните как '+filename);
}

/* UI wiring */
function init(){
  const sel=document.getElementById('langSelect');
  const saved=(localStorage.getItem(LANG_KEY)||'ru'); sel.value=saved; applyTranslations(saved);
  sel.addEventListener('change', e=>applyTranslations(e.target.value));

  document.getElementById('btnRequestMic').addEventListener('click', requestMicrophoneAccess);
  document.getElementById('btnStart').addEventListener('click', ()=>{
    if(!analyser){ setStatus('Сначала разрешите микрофон.','error'); return; }
    resetRecording();
    recording=true; t0=audioCtx.currentTime; lastT=t0;
    setStatus('🟢 Запись…','ok');
    requestAnimationFrame(function loop(){ tick(); });
  });
  document.getElementById('btnStop').addEventListener('click', stopRecordingAndFinalize);
  document.getElementById('btnReset').addEventListener('click', resetRecording);
  document.getElementById('btnStartNorm').addEventListener('click', ()=>setMode('normalization'));
  document.getElementById('btnFinishNorm').addEventListener('click', ()=>setMode('main'));
  document.getElementById('btnResetLast').addEventListener('click', ()=>{
    const mode=getMode();
    if(mode==='main'){ const h=loadEnergyHistoryMain(); if(h.length){ h.pop(); saveEnergyHistoryMain(h); } }
    else{ const h=loadEnergyHistory(); if(h.length){ h.pop(); saveEnergyHistory(h); } }
    drawEnergyHistory();
  });

  // Tech modal
  const techModal=document.getElementById('techModal');
  document.getElementById('btnTech').addEventListener('click', ()=>{
    const rel = Math.max(maxIntensity * getRelativeThresholdFraction(), ABSOLUTE_FLOOR);
    document.getElementById('thresholdInfo').textContent = 'Current threshold: ' + (rel?rel.toExponential(2):'—');
    document.getElementById('thrSlider').value = String(getThresholdPct());
    document.getElementById('thrValue').textContent = getThresholdPct().toFixed(1) + '%';
    document.getElementById('stabSlider').value = String(getStabilityPct());
    document.getElementById('stabValue').textContent = getStabilityPct().toFixed(2) + '%';
    techModal.style.display='block';
  });
  document.getElementById('btnCloseTech').addEventListener('click', ()=> techModal.style.display='none');
  techModal.addEventListener('click', ()=> techModal.style.display='none');
  document.querySelector('#techModal .modal-card').addEventListener('click', e=>e.stopPropagation());

  // Share
  document.getElementById('btnShare').addEventListener('click', exportHTMLReport);

  drawEnergyHistory();
}
window.addEventListener('load', init);
</script>
</body>
</html>
